<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <title>SAXTech Real-Time Azure Dashboard</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <!-- MSAL.js for Azure AD Authentication -->
  <script src="https://alcdn.msauth.net/browser/2.32.2/js/msal-browser.min.js"></script>
  
  <!-- Chart.js for cost graphs - using local file to avoid CSP issues -->
  <script src="chart.js"></script>
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #0a0e27 0%, #060818 100%);
      color: #e2e8f0;
      min-height: 100vh;
    }
    
    .header {
      background: rgba(15, 23, 41, 0.9);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(0, 212, 255, 0.2);
      padding: 20px;
      position: sticky;
      top: 0;
      z-index: 100;
    }
    
    .header-content {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .logo {
      font-size: 24px;
      font-weight: 800;
      background: linear-gradient(135deg, #00d4ff 0%, #7c3aed 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .user-section {
      display: flex;
      align-items: center;
      gap: 20px;
    }
    
    .user-info {
      display: none;
      align-items: center;
      gap: 15px;
    }
    
    .user-info.active {
      display: flex;
    }
    
    .user-email {
      color: #94a3b8;
      font-size: 14px;
    }
    
    .btn {
      background: linear-gradient(135deg, #00d4ff 0%, #7c3aed 100%);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      transition: transform 0.2s;
    }
    
    .btn:hover {
      transform: translateY(-2px);
    }
    
    .btn-secondary {
      background: rgba(124, 58, 237, 0.2);
      border: 1px solid rgba(124, 58, 237, 0.5);
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 30px 20px;
    }
    
    /* Auth Section */
    .auth-section {
      background: rgba(15, 23, 41, 0.6);
      border: 1px solid rgba(0, 212, 255, 0.2);
      border-radius: 12px;
      padding: 30px;
      margin-bottom: 30px;
      text-align: center;
    }
    
    .auth-section.hidden {
      display: none;
    }
    
    .auth-title {
      font-size: 20px;
      margin-bottom: 15px;
      color: #00d4ff;
    }
    
    .auth-description {
      color: #94a3b8;
      margin-bottom: 20px;
      font-size: 14px;
    }
    
    /* Status Messages */
    .status-message {
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      display: none;
    }
    
    .status-message.active {
      display: block;
    }
    
    .status-success {
      background: rgba(16, 185, 129, 0.1);
      border: 1px solid rgba(16, 185, 129, 0.3);
      color: #10b981;
    }
    
    .status-error {
      background: rgba(239, 68, 68, 0.1);
      border: 1px solid rgba(239, 68, 68, 0.3);
      color: #ef4444;
    }
    
    .status-info {
      background: rgba(59, 130, 246, 0.1);
      border: 1px solid rgba(59, 130, 246, 0.3);
      color: #3b82f6;
    }
    
    /* Dashboard Grid */
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .metric-card {
      background: rgba(15, 23, 41, 0.6);
      border: 1px solid rgba(0, 212, 255, 0.2);
      border-radius: 12px;
      padding: 20px;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    
    .metric-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 10px 30px rgba(0, 212, 255, 0.2);
    }
    
    .metric-label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #94a3b8;
      margin-bottom: 10px;
    }
    
    .metric-value {
      font-size: 32px;
      font-weight: 800;
      background: linear-gradient(135deg, #00d4ff 0%, #7c3aed 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 5px;
    }
    
    .metric-subtitle {
      font-size: 12px;
      color: #64748b;
    }
    
    .metric-loading {
      opacity: 0.5;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 0.8; }
    }
    
    /* Data Table */
    .data-section {
      background: rgba(15, 23, 41, 0.6);
      border: 1px solid rgba(0, 212, 255, 0.2);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .section-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 15px;
      color: #00d4ff;
    }
    
    .data-table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .data-table th {
      text-align: left;
      padding: 10px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #94a3b8;
      border-bottom: 1px solid rgba(0, 212, 255, 0.2);
    }
    
    .data-table td {
      padding: 10px;
      color: #e2e8f0;
      border-bottom: 1px solid rgba(0, 212, 255, 0.1);
    }
    
    .data-table tr:hover {
      background: rgba(0, 212, 255, 0.05);
    }
    
    /* Loading Spinner */
    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(0, 212, 255, 0.3);
      border-top-color: #00d4ff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Settings Panel */
    .settings-panel {
      background: rgba(15, 23, 41, 0.8);
      border: 1px solid rgba(0, 212, 255, 0.2);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .input-group {
      margin-bottom: 15px;
    }
    
    .input-label {
      display: block;
      font-size: 12px;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 5px;
    }
    
    .input-field {
      width: 100%;
      background: rgba(6, 8, 24, 0.6);
      border: 1px solid rgba(0, 212, 255, 0.2);
      color: #e2e8f0;
      padding: 10px;
      border-radius: 6px;
      font-size: 14px;
    }
    
    .input-field:focus {
      outline: none;
      border-color: #00d4ff;
      box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.1);
    }
    
    .code-block {
      background: rgba(6, 8, 24, 0.8);
      border: 1px solid rgba(0, 212, 255, 0.2);
      border-radius: 8px;
      padding: 15px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      color: #00d4ff;
      overflow-x: auto;
      margin: 10px 0;
    }
    
    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      animation: fadeIn 0.3s;
    }
    
    .modal.active {
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .modal-content {
      background: linear-gradient(135deg, #0a0e27 0%, #060818 100%);
      border: 1px solid rgba(0, 212, 255, 0.3);
      border-radius: 16px;
      padding: 30px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      overflow-y: auto;
      animation: slideIn 0.3s;
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(0, 212, 255, 0.2);
    }
    
    .modal-title {
      font-size: 24px;
      font-weight: 700;
      background: linear-gradient(135deg, #00d4ff 0%, #7c3aed 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .modal-close {
      background: none;
      border: none;
      font-size: 28px;
      color: #94a3b8;
      cursor: pointer;
      transition: color 0.2s;
    }
    
    .modal-close:hover {
      color: #00d4ff;
    }
    
    .modal-body {
      color: #e2e8f0;
    }
    
    .detail-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin: 20px 0;
    }
    
    .detail-item {
      background: rgba(15, 23, 41, 0.6);
      border: 1px solid rgba(0, 212, 255, 0.1);
      border-radius: 8px;
      padding: 15px;
    }
    
    .detail-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #94a3b8;
      margin-bottom: 5px;
    }
    
    .detail-value {
      font-size: 18px;
      font-weight: 600;
      color: #00d4ff;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    @keyframes slideIn {
      from {
        transform: translateY(-50px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
  </style>
</head>
<body>
  <header class="header">
    <div class="header-content">
      <div class="logo">SAXTech Real-Time Azure Dashboard</div>
      <div class="user-section">
        <button id="signInButton" class="btn" onclick="signIn()">Sign In with Azure AD</button>
        <div id="userInfo" class="user-info">
          <span class="user-email" id="userEmail">Not signed in</span>
          <button class="btn btn-secondary" onclick="refreshData()">🔄 Refresh</button>
          <button class="btn" onclick="signOut()">Sign Out</button>
        </div>
      </div>
    </div>
  </header>

  <div class="container">
    <!-- Authentication Section -->
    <div id="authSection" class="auth-section">
      <h2 class="auth-title">🔐 Azure AD Authentication Required</h2>
      <p class="auth-description">
        This dashboard connects directly to Azure Management APIs for real-time data.<br>
        Please sign in with your Azure AD account to continue.
      </p>
      <button class="btn" onclick="signIn()">Sign In with Microsoft Account</button>
    </div>

    <!-- Status Messages -->
    <div id="statusMessage" class="status-message"></div>

    <!-- Main Dashboard (Hidden until authenticated) -->
    <div id="mainDashboard" style="display: none;">
      <!-- Cost Metrics -->
      <div class="dashboard-grid">
        <div class="metric-card" onclick="window.drillDownMetric('mtd')" style="cursor: pointer;" title="Click for details">
          <div class="metric-label">Month-to-Date Cost</div>
          <div class="metric-value" id="mtdCost">--</div>
          <div class="metric-subtitle" id="mtdDates">Loading...</div>
        </div>
        
        <div class="metric-card" onclick="window.drillDownMetric('yesterday')" style="cursor: pointer;" title="Click for details">
          <div class="metric-label">Yesterday's Cost</div>
          <div class="metric-value" id="yesterdayCost">--</div>
          <div class="metric-subtitle" id="yesterdayDate">--</div>
        </div>
        
        <div class="metric-card" onclick="window.drillDownMetric('today')" style="cursor: pointer;" title="Click for details">
          <div class="metric-label">Today's Cost (Live)</div>
          <div class="metric-value" id="todayCost">--</div>
          <div class="metric-subtitle">Real-time from Azure</div>
        </div>
        
        <div class="metric-card" onclick="window.drillDownMetric('week')" style="cursor: pointer;" title="Click for details">
          <div class="metric-label">Last 7 Days</div>
          <div class="metric-value" id="weekCost">--</div>
          <div class="metric-subtitle">Weekly spending</div>
        </div>
      </div>

      <!-- Resource Counts -->
      <div class="dashboard-grid">
        <div class="metric-card" onclick="window.drillDownResourceType('resourceGroups')" style="cursor: pointer;" title="Click for details">
          <div class="metric-label">Resource Groups</div>
          <div class="metric-value" id="rgCount">--</div>
          <div class="metric-subtitle">Active groups</div>
        </div>
        
        <div class="metric-card" onclick="window.drillDownResourceType('virtualMachines')" style="cursor: pointer;" title="Click for details">
          <div class="metric-label">Virtual Machines</div>
          <div class="metric-value" id="vmCount">--</div>
          <div class="metric-subtitle" id="vmStatus">--</div>
        </div>
        
        <div class="metric-card" onclick="window.drillDownResourceType('storageAccounts')" style="cursor: pointer;" title="Click for details">
          <div class="metric-label">Storage Accounts</div>
          <div class="metric-value" id="storageCount">--</div>
          <div class="metric-subtitle">Total accounts</div>
        </div>
        
        <div class="metric-card" onclick="window.drillDownResourceType('webApps')" style="cursor: pointer;" title="Click for details">
          <div class="metric-label">Web Apps</div>
          <div class="metric-value" id="webAppCount">--</div>
          <div class="metric-subtitle">Static + Function</div>
        </div>
      </div>

      <!-- Backup & Disaster Recovery Status -->
      <div class="data-section">
        <h3 class="section-title">🔒 Backup & Disaster Recovery Status</h3>
        <div class="dashboard-grid">
          <div class="metric-card" style="border-color: rgba(16, 185, 129, 0.3); cursor: pointer;" onclick="window.explainBackupStatus('azure')" title="Click for details">
            <div class="metric-label">Azure Backups Repository</div>
            <div class="metric-value" id="azureBackupStatus" style="font-size: 24px;">⏳</div>
            <div class="metric-subtitle" id="azureBackupTime">Checking...</div>
          </div>
          
          <div class="metric-card" style="border-color: rgba(16, 185, 129, 0.3); cursor: pointer;" onclick="window.explainBackupStatus('k8s')" title="Click for details">
            <div class="metric-label">Kubernetes (n8n-aks) Backup</div>
            <div class="metric-value" id="k8sBackupStatus" style="font-size: 24px;">⏳</div>
            <div class="metric-subtitle" id="k8sBackupTime">Checking...</div>
          </div>
          
          <div class="metric-card" style="border-color: rgba(16, 185, 129, 0.3); cursor: pointer;" onclick="window.explainBackupStatus('postgres')" title="Click for details">
            <div class="metric-label">PostgreSQL Maintenance</div>
            <div class="metric-value" id="postgresStatus" style="font-size: 24px;">⏳</div>
            <div class="metric-subtitle" id="postgresTime">Checking...</div>
          </div>
          
          <div class="metric-card" style="border-color: rgba(16, 185, 129, 0.3); cursor: pointer;" onclick="window.explainBackupStatus('vault')" title="Click for details">
            <div class="metric-label">Recovery Vault</div>
            <div class="metric-value" id="vaultStatus" style="font-size: 24px;">⏳</div>
            <div class="metric-subtitle" id="vaultItems">Checking...</div>
          </div>
        </div>
      </div>

      <!-- Function Apps Information -->
      <div class="data-section" id="functionAppsSection" style="display: none;">
        <h3 class="section-title">⚡ Function Apps Details</h3>
        <div class="dashboard-grid">
          <div class="metric-card">
            <div class="metric-label">Total Function Apps</div>
            <div class="metric-value" id="functionAppCount" style="font-size: 24px;">--</div>
            <div class="metric-subtitle" id="functionAppStatus">--</div>
          </div>
          
          <div class="metric-card">
            <div class="metric-label">Total Functions</div>
            <div class="metric-value" id="totalFunctionsCount" style="font-size: 24px;">--</div>
            <div class="metric-subtitle">Across all apps</div>
          </div>
          
          <div class="metric-card">
            <div class="metric-label">Last Invocation</div>
            <div class="metric-value" id="lastInvocationStatus" style="font-size: 20px;">--</div>
            <div class="metric-subtitle" id="lastInvocationTime">--</div>
          </div>
          
          <div class="metric-card">
            <div class="metric-label">Total Executions (24h)</div>
            <div class="metric-value" id="executionCount24h" style="font-size: 24px;">--</div>
            <div class="metric-subtitle">Last 24 hours</div>
          </div>
        </div>
        
        <div style="margin-top: 20px;">
          <h4 style="color: #00d4ff; margin-bottom: 10px;">Function Apps List</h4>
          <table class="data-table">
            <thead>
              <tr>
                <th>App Name</th>
                <th>Status</th>
                <th>OS/Runtime</th>
                <th>SKU</th>
                <th>Functions</th>
                <th>Last Run</th>
                <th>URL</th>
              </tr>
            </thead>
            <tbody id="functionAppsTable">
              <tr><td colspan="7" style="text-align: center;">Loading...</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- Kubernetes Cluster Information -->
      <div class="data-section" id="k8sClusterSection" style="display: none;">
        <h3 class="section-title">☸️ Kubernetes Cluster Details</h3>
        <div class="dashboard-grid">
          <div class="metric-card">
            <div class="metric-label">Cluster Name</div>
            <div class="metric-value" id="k8sClusterName" style="font-size: 20px;">--</div>
            <div class="metric-subtitle" id="k8sClusterVersion">--</div>
          </div>
          
          <div class="metric-card">
            <div class="metric-label">Node Pools</div>
            <div class="metric-value" id="k8sNodeCount">--</div>
            <div class="metric-subtitle" id="k8sNodeStatus">--</div>
          </div>
          
          <div class="metric-card">
            <div class="metric-label">CPU Usage</div>
            <div class="metric-value" id="k8sCpuUsage">--</div>
            <div class="metric-subtitle">Allocated / Total</div>
          </div>
          
          <div class="metric-card">
            <div class="metric-label">Memory Usage</div>
            <div class="metric-value" id="k8sMemoryUsage">--</div>
            <div class="metric-subtitle">Allocated / Total</div>
          </div>
        </div>
        
        <div style="margin-top: 20px;">
          <h4 style="color: #00d4ff; margin-bottom: 10px;">Ingress Configuration</h4>
          <div class="code-block" id="k8sIngressConfig">
            Loading nginx configuration...
          </div>
        </div>
        
        <div style="margin-top: 20px;">
          <h4 style="color: #00d4ff; margin-bottom: 10px;">Active Workloads</h4>
          <table class="data-table">
            <thead>
              <tr>
                <th>Workload</th>
                <th>Type</th>
                <th>Replicas</th>
                <th>Status</th>
                <th>CPU</th>
                <th>Memory</th>
              </tr>
            </thead>
            <tbody id="k8sWorkloadsTable">
              <tr><td colspan="6" style="text-align: center;">Loading...</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- Month-to-Date Cost Graph -->
      <div class="data-section">
        <h3 class="section-title">📊 Month-to-Date Cost Trend</h3>
        <div style="position: relative; height: 300px; margin: 20px 0;">
          <canvas id="mtdCostChart"></canvas>
        </div>
        <div class="dashboard-grid" style="margin-top: 20px;">
          <div class="metric-card">
            <div class="metric-label">Highest Day</div>
            <div class="metric-value" id="highestDayCost" style="font-size: 20px;">--</div>
            <div class="metric-subtitle" id="highestDayDate">--</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Lowest Day</div>
            <div class="metric-value" id="lowestDayCost" style="font-size: 20px;">--</div>
            <div class="metric-subtitle" id="lowestDayDate">--</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Average Daily</div>
            <div class="metric-value" id="avgDailyCost" style="font-size: 20px;">--</div>
            <div class="metric-subtitle">This month</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Projected Month End</div>
            <div class="metric-value" id="projectedCost" style="font-size: 20px;">--</div>
            <div class="metric-subtitle">Based on current trend</div>
          </div>
        </div>
      </div>

      <!-- Detailed Cost Breakdown -->
      <div class="data-section">
        <h3 class="section-title">Cost Breakdown by Service (Last 30 Days)</h3>
        <table class="data-table">
          <thead>
            <tr>
              <th>Service</th>
              <th>Resource Count</th>
              <th>Month-to-Date</th>
              <th>Daily Average</th>
              <th>% of Total</th>
            </tr>
          </thead>
          <tbody id="costBreakdownTable">
            <tr><td colspan="5" style="text-align: center;"><div class="spinner"></div></td></tr>
          </tbody>
        </table>
      </div>

      <!-- Resources List -->
      <div class="data-section">
        <h3 class="section-title">All Resources by Cost</h3>
        <div style="max-height: 500px; overflow-y: auto;">
          <table class="data-table">
            <thead style="position: sticky; top: 0; background: rgba(15, 23, 41, 0.95); z-index: 10;">
              <tr>
                <th>Resource Name</th>
                <th>Type</th>
                <th>Resource Group</th>
                <th>Location</th>
                <th>Status</th>
                <th>MTD Cost</th>
              </tr>
            </thead>
            <tbody id="resourcesTable">
              <tr><td colspan="5" style="text-align: center;"><div class="spinner"></div></td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- GPT Models Usage Tracking -->
      <div class="data-section">
        <h3 class="section-title">🤖 AI Models Usage Tracking</h3>
        <div class="dashboard-grid">
          <div class="metric-card">
            <div class="metric-label">GPT-4o Mini</div>
            <div class="metric-value" id="gpt4oMiniTokens" style="font-size: 20px;">0</div>
            <div class="metric-subtitle">Tokens this month</div>
            <div class="input-group" style="margin-top: 10px;">
              <input type="number" class="input-field" id="gpt4oMiniInput" placeholder="Add tokens" step="1000" style="margin: 5px 0;">
              <button class="btn btn-secondary" onclick="addTokenUsage('gpt4o-mini')" style="width: 100%; margin-top: 5px;">Add Usage</button>
            </div>
            <div class="metric-subtitle" style="margin-top: 5px; color: #00d4ff;" id="gpt4oMiniCost">$0.00</div>
          </div>
          
          <div class="metric-card">
            <div class="metric-label">Embeddings (text-embedding-3)</div>
            <div class="metric-value" id="embeddingsTokens" style="font-size: 20px;">0</div>
            <div class="metric-subtitle">Tokens this month</div>
            <div class="input-group" style="margin-top: 10px;">
              <input type="number" class="input-field" id="embeddingsInput" placeholder="Add tokens" step="10000" style="margin: 5px 0;">
              <button class="btn btn-secondary" onclick="addTokenUsage('embeddings')" style="width: 100%; margin-top: 5px;">Add Usage</button>
            </div>
            <div class="metric-subtitle" style="margin-top: 5px; color: #00d4ff;" id="embeddingsCost">$0.00</div>
          </div>
          
          <div class="metric-card">
            <div class="metric-label">Azure Document Intelligence</div>
            <div class="metric-value" id="documentPages" style="font-size: 20px;">0</div>
            <div class="metric-subtitle">Pages processed</div>
            <div class="input-group" style="margin-top: 10px;">
              <input type="number" class="input-field" id="documentInput" placeholder="Add pages" step="100" style="margin: 5px 0;">
              <select class="input-field" id="documentModel" style="margin: 5px 0;">
                <option value="prebuilt-read">Read (OCR)</option>
                <option value="prebuilt-layout">Layout</option>
                <option value="prebuilt-document">Document</option>
                <option value="prebuilt-invoice">Invoice</option>
              </select>
              <button class="btn btn-secondary" onclick="addTokenUsage('document')" style="width: 100%; margin-top: 5px;">Add Usage</button>
            </div>
            <div class="metric-subtitle" style="margin-top: 5px; color: #00d4ff;" id="documentCost">$0.00</div>
          </div>
          
          <div class="metric-card">
            <div class="metric-label">Custom/Other Models</div>
            <div class="metric-value" id="customUsage" style="font-size: 20px;">--</div>
            <div class="metric-subtitle">Various usage</div>
            <div class="input-group" style="margin-top: 10px;">
              <input type="text" class="input-field" id="customModelName" placeholder="Model name" style="margin: 5px 0;">
              <input type="number" class="input-field" id="customCost" placeholder="Cost ($)" step="0.01" style="margin: 5px 0;">
              <button class="btn btn-secondary" onclick="addTokenUsage('custom')" style="width: 100%; margin-top: 5px;">Add Cost</button>
            </div>
            <div class="metric-subtitle" style="margin-top: 5px; color: #00d4ff;" id="customTotalCost">$0.00</div>
          </div>
        </div>
        
        <div class="dashboard-grid" style="margin-top: 20px;">
          <div class="metric-card" style="border-color: rgba(16, 185, 129, 0.3);">
            <div class="metric-label">Total AI Models Cost</div>
            <div class="metric-value" id="totalAiCost" style="font-size: 24px;">$0.00</div>
            <div class="metric-subtitle">This month</div>
          </div>
          
          <div class="metric-card" style="border-color: rgba(16, 185, 129, 0.3);">
            <div class="metric-label">API Usage History</div>
            <div style="max-height: 100px; overflow-y: auto;" id="apiUsageHistory">
              <div style="color: #94a3b8; font-size: 12px;">No usage recorded</div>
            </div>
          </div>
          
          <div class="metric-card" style="border-color: rgba(16, 185, 129, 0.3);">
            <div class="metric-label">Estimated Daily Rate</div>
            <div class="metric-value" id="aiDailyRate" style="font-size: 24px;">$0.00</div>
            <div class="metric-subtitle">Based on usage</div>
          </div>
          
          <div class="metric-card" style="border-color: rgba(16, 185, 129, 0.3);">
            <div class="metric-label">Projected Monthly</div>
            <div class="metric-value" id="aiProjectedMonthly" style="font-size: 24px;">$0.00</div>
            <div class="metric-subtitle">At current rate</div>
          </div>
        </div>
        
        <div style="margin-top: 20px; padding: 15px; background: rgba(15, 23, 41, 0.4); border-radius: 8px;">
          <h4 style="color: #00d4ff; margin-bottom: 10px;">Azure OpenAI Service Tracking</h4>
          <div class="input-group">
            <button class="btn btn-secondary" onclick="fetchAzureOpenAIUsage()" style="margin-top: 5px;">Fetch Azure OpenAI Usage</button>
            <button class="btn btn-secondary" onclick="fetchCognitiveServicesUsage()" style="margin-top: 5px; margin-left: 10px;">Fetch Cognitive Services</button>
          </div>
          <div class="metric-subtitle" id="apiKeyStatus" style="margin-top: 10px;">Connected via Azure AD authentication</div>
          <div class="code-block" style="margin-top: 10px; font-size: 11px;">
            <strong>Note:</strong> GPT usage is now tracked through Azure OpenAI Service.<br>
            Your Azure subscription includes access to GPT-4, GPT-3.5, and embeddings models.<br>
            Usage is automatically tracked through Azure Cost Management.
          </div>
        </div>
      </div>

      <!-- Manual Tool Cost Tracking -->
      <div class="data-section">
        <h3 class="section-title">💳 Manual Tool Cost Tracking</h3>
        <div class="dashboard-grid">
          <div class="metric-card">
            <div class="metric-label">WARP (Terminal)</div>
            <div class="input-group">
              <input type="number" class="input-field" id="warpCost" placeholder="Monthly cost" step="0.01" style="margin: 5px 0;">
            </div>
            <button class="btn btn-secondary" onclick="saveToolCost('warp')" style="width: 100%; margin-top: 5px;">Save</button>
            <div class="metric-subtitle" id="warpSaved" style="margin-top: 5px;">$0.00/month</div>
          </div>
          
          <div class="metric-card">
            <div class="metric-label">Claude (Anthropic)</div>
            <div class="input-group">
              <input type="number" class="input-field" id="claudeCost" placeholder="Monthly cost" step="0.01" style="margin: 5px 0;">
            </div>
            <button class="btn btn-secondary" onclick="saveToolCost('claude')" style="width: 100%; margin-top: 5px;">Save</button>
            <div class="metric-subtitle" id="claudeSaved" style="margin-top: 5px;">$0.00/month</div>
          </div>
          
          <div class="metric-card">
            <div class="metric-label">ChatGPT (OpenAI)</div>
            <div class="input-group">
              <input type="number" class="input-field" id="chatgptCost" placeholder="Monthly cost" step="0.01" style="margin: 5px 0;">
            </div>
            <button class="btn btn-secondary" onclick="saveToolCost('chatgpt')" style="width: 100%; margin-top: 5px;">Save</button>
            <div class="metric-subtitle" id="chatgptSaved" style="margin-top: 5px;">$0.00/month</div>
          </div>
          
          <div class="metric-card">
            <div class="metric-label">Other Tools</div>
            <div class="input-group">
              <input type="text" class="input-field" id="otherToolName" placeholder="Tool name" style="margin: 5px 0;">
              <input type="number" class="input-field" id="otherToolCost" placeholder="Monthly cost" step="0.01" style="margin: 5px 0;">
            </div>
            <button class="btn btn-secondary" onclick="saveToolCost('other')" style="width: 100%; margin-top: 5px;">Add Tool</button>
            <div class="metric-subtitle" id="otherToolsList" style="margin-top: 5px; max-height: 100px; overflow-y: auto;">No tools added</div>
          </div>
        </div>
        
        <div class="dashboard-grid" style="margin-top: 20px;">
          <div class="metric-card" style="border-color: rgba(124, 58, 237, 0.3);">
            <div class="metric-label">Total Manual Tools Cost</div>
            <div class="metric-value" id="totalToolsCost" style="font-size: 24px;">$0.00</div>
            <div class="metric-subtitle">Per month</div>
          </div>
          
          <div class="metric-card" style="border-color: rgba(124, 58, 237, 0.3);">
            <div class="metric-label">Combined Monthly Cost</div>
            <div class="metric-value" id="combinedMonthlyCost" style="font-size: 24px;">$0.00</div>
            <div class="metric-subtitle">Azure + Tools</div>
          </div>
          
          <div class="metric-card" style="border-color: rgba(124, 58, 237, 0.3);">
            <div class="metric-label">Annual Projection</div>
            <div class="metric-value" id="annualProjection" style="font-size: 24px;">$0.00</div>
            <div class="metric-subtitle">Total yearly cost</div>
          </div>
          
          <div class="metric-card" style="border-color: rgba(124, 58, 237, 0.3);">
            <div class="metric-label">Cost per Day</div>
            <div class="metric-value" id="dailyCostEstimate" style="font-size: 24px;">$0.00</div>
            <div class="metric-subtitle">Average daily spend</div>
          </div>
        </div>
      </div>

      <!-- Settings -->
      <div class="settings-panel">
        <h3 class="section-title">Azure Configuration</h3>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
          <div class="input-group">
            <label class="input-label">Subscription ID</label>
            <input type="text" class="input-field" id="subscriptionId" value="3cfb259a-f02a-484e-9ce3-d83c21fd0ddb">
          </div>
          <div class="input-group">
            <label class="input-label">Tenant ID</label>
            <input type="text" class="input-field" id="tenantId" value="3d659328-eef0-44f7-8481-5833e1051aec" readonly>
          </div>
        </div>
        <div style="margin-top: 15px;">
          <button class="btn btn-secondary" onclick="updateSubscription()">Update Subscription</button>
          <button class="btn btn-secondary" onclick="testConnection()">Test Connection</button>
        </div>
        
        <div class="code-block" style="margin-top: 20px;">
          <strong>API Endpoints Being Used:</strong><br>
          Cost Management: https://management.azure.com/subscriptions/{subscriptionId}/providers/Microsoft.CostManagement/query<br>
          Resources: https://management.azure.com/subscriptions/{subscriptionId}/resources<br>
          Resource Groups: https://management.azure.com/subscriptions/{subscriptionId}/resourcegroups
        </div>
      </div>
    </div>
  </div>

  <!-- Detail Modal -->
  <div id="detailModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="modalTitle">Details</h2>
        <button class="modal-close" onclick="closeModal()">&times;</button>
      </div>
      <div class="modal-body" id="modalBody">
        <!-- Content will be dynamically inserted here -->
      </div>
    </div>
  </div>

  <script>
    // MSAL Configuration
    const msalConfig = {
      auth: {
        clientId: 'c1a20824-c427-46f0-a819-53d657d6ea7f', // SAXTech Real-Time Dashboard App
        authority: 'https://login.microsoftonline.com/3d659328-eef0-44f7-8481-5833e1051aec',
        // Use the specific domain to avoid redirect URI mismatch
        redirectUri: 'https://repository.saxtechnology.com/realtime-dashboard.html',
        navigateToLoginRequestUrl: false // Prevent automatic navigation to avoid loops
      },
      cache: {
        cacheLocation: 'localStorage',
        storeAuthStateInCookie: true // Enable cookie storage for better compatibility
      },
      system: {
        loggerOptions: {
          loggerCallback: (level, message, containsPii) => {
            if (containsPii) return;
            console.log(message);
          },
          logLevel: msal.LogLevel.Warning
        }
      }
    };

    // MSAL Instance
    const msalInstance = new msal.PublicClientApplication(msalConfig);

    // Azure Management API Scopes
    const loginRequest = {
      scopes: ['https://management.azure.com/user_impersonation']
    };

    const tokenRequest = {
      scopes: ['https://management.azure.com/.default'],
      forceRefresh: false
    };

    let currentAccount = null;
    let isAuthenticating = false; // Guard against concurrent auth attempts

    // Initialize MSAL
    async function initializeMSAL() {
      console.log('Initializing MSAL...');
      
      try {
        // Always handle redirect promise first, even if there's no apparent redirect
        const response = await msalInstance.handleRedirectPromise();
        
        if (response && response.account) {
          console.log('Login successful via redirect!');
          currentAccount = response.account;
          msalInstance.setActiveAccount(response.account);
          
          // Clear the URL parameters to prevent loops
          const urlParams = new URLSearchParams(window.location.search);
          if (urlParams.has('code') || urlParams.has('error') || urlParams.has('state')) {
            window.history.replaceState({}, document.title, window.location.pathname);
          }
          
          showMessage('Successfully signed in!', 'success');
          await onSignIn();
          return;
        }
        
        // Check if we have URL parameters indicating a failed redirect
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('error')) {
          const error = urlParams.get('error');
          const errorDesc = urlParams.get('error_description');
          console.error('Auth error from redirect:', error, errorDesc);
          window.history.replaceState({}, document.title, window.location.pathname);
          showMessage(`Authentication failed: ${errorDesc || error}`, 'error');
        }
        
        // Check for existing accounts
        const accounts = msalInstance.getAllAccounts();
        if (accounts && accounts.length > 0) {
          console.log('Found existing account');
          currentAccount = accounts[0];
          msalInstance.setActiveAccount(accounts[0]);
          await onSignIn();
        } else {
          console.log('No authenticated user, showing login UI');
          document.getElementById('authSection').classList.remove('hidden');
        }
        
      } catch (error) {
        console.error('MSAL initialization error:', error);
        
        // Clear any auth-related URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('code') || urlParams.has('error') || urlParams.has('state')) {
          window.history.replaceState({}, document.title, window.location.pathname);
        }
        
        // Only show error if it's not an interaction_in_progress error
        if (!error.errorCode || error.errorCode !== 'interaction_in_progress') {
          showMessage('Authentication error: ' + error.message, 'error');
        }
        
        document.getElementById('authSection').classList.remove('hidden');
      } finally {
        // Reset auth flag
        isAuthenticating = false;
      }
    }

    // Sign In
    async function signIn() {
      // Prevent concurrent authentication attempts
      if (isAuthenticating) {
        console.log('Authentication already in progress, skipping...');
        return;
      }
      
      isAuthenticating = true;
      
      try {
        console.log('Starting sign in process...');
        
        // Check if we're already authenticated
        const accounts = msalInstance.getAllAccounts();
        if (accounts && accounts.length > 0) {
          console.log('Already have an account, using it');
          currentAccount = accounts[0];
          msalInstance.setActiveAccount(accounts[0]);
          await onSignIn();
          return;
        }
        
        // Check for interaction in progress error
        try {
          // Try to get active account first
          const activeAccount = msalInstance.getActiveAccount();
          if (activeAccount) {
            currentAccount = activeAccount;
            await onSignIn();
            return;
          }
        } catch (e) {
          console.log('No active account found');
        }
        
        // Determine authentication method
        const usePopup = localStorage.getItem('usePopupAuth') === 'true';
        
        if (usePopup) {
          console.log('Using popup authentication');
          showMessage('Opening Microsoft login popup...', 'info');
          
          try {
            const response = await msalInstance.loginPopup({
              ...loginRequest,
              prompt: 'select_account'
            });
            
            if (response && response.account) {
              currentAccount = response.account;
              msalInstance.setActiveAccount(response.account);
              showMessage('Successfully signed in!', 'success');
              await onSignIn();
            }
          } catch (popupError) {
            if (popupError.errorCode === 'popup_window_error' || popupError.errorCode === 'empty_window_error') {
              console.warn('Popup blocked or closed, trying redirect');
              localStorage.removeItem('usePopupAuth');
              showMessage('Popup was blocked. Trying redirect authentication...', 'info');
              
              // Try redirect as fallback
              await msalInstance.loginRedirect({
                ...loginRequest,
                redirectUri: 'https://repository.saxtechnology.com/realtime-dashboard.html',
                prompt: 'select_account'
              });
            } else {
              throw popupError;
            }
          }
        } else {
          console.log('Using redirect authentication');
          
          // Check for recent redirect attempts
          const lastRedirect = localStorage.getItem('lastAuthRedirect');
          const now = Date.now();
          
          if (lastRedirect && (now - parseInt(lastRedirect)) < 10000) {
            console.warn('Recent redirect detected, switching to popup to avoid loop');
            localStorage.setItem('usePopupAuth', 'true');
            
            showMessage('Opening Microsoft login popup...', 'info');
            const response = await msalInstance.loginPopup({
              ...loginRequest,
              prompt: 'select_account'
            });
            
            if (response && response.account) {
              currentAccount = response.account;
              msalInstance.setActiveAccount(response.account);
              showMessage('Successfully signed in!', 'success');
              await onSignIn();
            }
          } else {
            showMessage('Redirecting to Microsoft login...', 'info');
            localStorage.setItem('lastAuthRedirect', now.toString());
            
            await msalInstance.loginRedirect({
              ...loginRequest,
              redirectUri: 'https://repository.saxtechnology.com/realtime-dashboard.html',
              prompt: 'select_account'
            });
          }
        }
      } catch (error) {
        console.error('Login error:', error);
        
        // Handle specific error codes
        if (error.errorCode === 'interaction_in_progress') {
          console.log('Interaction already in progress, waiting...');
          showMessage('Authentication in progress, please wait...', 'info');
          
          // Wait a bit and check if we're authenticated
          setTimeout(async () => {
            const accounts = msalInstance.getAllAccounts();
            if (accounts && accounts.length > 0) {
              currentAccount = accounts[0];
              msalInstance.setActiveAccount(accounts[0]);
              await onSignIn();
            } else {
              showMessage('Please try signing in again', 'info');
            }
          }, 2000);
        } else if (error.errorCode === 'user_cancelled') {
          showMessage('Sign in cancelled', 'info');
        } else {
          showMessage('Login failed: ' + (error.message || 'Unknown error'), 'error');
          
          // If redirect fails, suggest popup
          if (error.message && error.message.includes('redirect')) {
            localStorage.setItem('usePopupAuth', 'true');
            showMessage('Redirect failed. Click Sign In to try popup authentication.', 'info');
          }
        }
      } finally {
        // Reset authentication flag after a delay
        setTimeout(() => {
          isAuthenticating = false;
        }, 1000);
      }
    }

    // Sign Out
    function signOut() {
      msalInstance.logoutRedirect({
        account: currentAccount
      });
    }

    // Handle successful sign in
    async function onSignIn() {
      if (!currentAccount) return;

      // Update UI
      document.getElementById('authSection').classList.add('hidden');
      document.getElementById('signInButton').style.display = 'none';
      document.getElementById('userInfo').classList.add('active');
      document.getElementById('userEmail').textContent = currentAccount.username || currentAccount.name;
      document.getElementById('mainDashboard').style.display = 'block';

      // Load data
      await refreshData();
    }

    // Get Access Token
    async function getAccessToken() {
      try {
        const response = await msalInstance.acquireTokenSilent({
          ...tokenRequest,
          account: currentAccount
        });
        return response.accessToken;
      } catch (error) {
        console.error('Token acquisition failed, attempting interactive:', error);
        const response = await msalInstance.acquireTokenRedirect(tokenRequest);
        return response.accessToken;
      }
    }

    // Rate limiting configuration
    const rateLimitConfig = {
      costApiDelay: 10000, // 10 seconds between Cost API calls
      maxRetries: 3,
      retryDelay: 30000 // 30 seconds between retries for 429 errors
    };
    
    let lastCostApiCall = 0;
    
    // Sleep function for delays
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    // Azure API Helper with retry logic
    async function callAzureAPI(endpoint, options = {}, retryCount = 0) {
      try {
        // Rate limiting for Cost Management API
        if (endpoint.includes('/providers/Microsoft.CostManagement/')) {
          const now = Date.now();
          const timeSinceLastCall = now - lastCostApiCall;
          if (timeSinceLastCall < rateLimitConfig.costApiDelay) {
            await sleep(rateLimitConfig.costApiDelay - timeSinceLastCall);
          }
          lastCostApiCall = Date.now();
        }
        
        const token = await getAccessToken();
        const response = await fetch(`https://management.azure.com${endpoint}`, {
          ...options,
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json',
            ...options.headers
          }
        });

        if (!response.ok) {
          // Handle rate limiting (429)
          if (response.status === 429 && retryCount < rateLimitConfig.maxRetries) {
            console.log(`Rate limited. Retrying in ${rateLimitConfig.retryDelay}ms... (Attempt ${retryCount + 1}/${rateLimitConfig.maxRetries})`);
            await sleep(rateLimitConfig.retryDelay);
            return callAzureAPI(endpoint, options, retryCount + 1);
          }
          
          // Try to get error details from response
          let errorMessage = `${response.status} ${response.statusText}`;
          try {
            const errorData = await response.json();
            if (errorData.error) {
              errorMessage = errorData.error.message || errorData.error.code || errorMessage;
            }
            console.error('API Error Details:', errorData);
          } catch (e) {
            // Response wasn't JSON
          }
          throw new Error(`API Error: ${errorMessage}`);
        }

        return await response.json();
      } catch (error) {
        console.error('Azure API call failed:', error);
        throw error;
      }
    }

    // Get Cost Data
    async function getCostData(timeframe = 'MonthToDate') {
      const subscriptionId = document.getElementById('subscriptionId').value;
      const endpoint = `/subscriptions/${subscriptionId}/providers/Microsoft.CostManagement/query?api-version=2023-03-01`;
      
      const body = {
        type: 'ActualCost',
        dataSet: {
          granularity: 'Daily',
          aggregation: {
            totalCost: {
              name: 'Cost',
              function: 'Sum'
            },
            totalCostUSD: {
              name: 'CostUSD',
              function: 'Sum'
            }
          },
          grouping: [
            {
              type: 'Dimension',
              name: 'ServiceName'  // This might be returning codes instead of names
            }
          ]
        },
        timeframe: timeframe
      };

      const result = await callAzureAPI(endpoint, {
        method: 'POST',
        body: JSON.stringify(body)
      });
      
      // Log to see what Azure is actually returning
      if (result?.properties?.rows && result.properties.rows.length > 0) {
        console.log('Sample service names from Azure:', result.properties.rows.slice(0, 3).map(r => r[0]));
      }
      
      return result;
    }

    // Get Custom Date Range Cost
    async function getCostForDateRange(startDate, endDate) {
      const subscriptionId = document.getElementById('subscriptionId').value;
      const endpoint = `/subscriptions/${subscriptionId}/providers/Microsoft.CostManagement/query?api-version=2023-03-01`;
      
      const body = {
        type: 'ActualCost',
        dataSet: {
          granularity: 'Daily',
          aggregation: {
            totalCost: {
              name: 'Cost',
              function: 'Sum'
            },
            totalCostUSD: {
              name: 'CostUSD',
              function: 'Sum'
            }
          }
        },
        timeframe: 'Custom',
        timePeriod: {
          from: startDate + 'T00:00:00Z',
          to: endDate + 'T23:59:59Z'
        }
      };

      return await callAzureAPI(endpoint, {
        method: 'POST',
        body: JSON.stringify(body)
      });
    }

    // Get Resources
    async function getResources() {
      const subscriptionId = document.getElementById('subscriptionId').value;
      return await callAzureAPI(`/subscriptions/${subscriptionId}/resources?api-version=2023-07-01`);
    }

    // Get Resource Groups
    async function getResourceGroups() {
      const subscriptionId = document.getElementById('subscriptionId').value;
      return await callAzureAPI(`/subscriptions/${subscriptionId}/resourcegroups?api-version=2023-07-01`);
    }

    // Get Storage Account Metrics
    async function getStorageAccountMetrics(storageAccountName, resourceGroup) {
      try {
        const subscriptionId = document.getElementById('subscriptionId').value;
        
        // Get storage account details
        const storageEndpoint = `/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/providers/Microsoft.Storage/storageAccounts/${storageAccountName}?api-version=2023-01-01`;
        const storageAccount = await callAzureAPI(storageEndpoint);
        
        // Try to get blob service properties
        let metrics = {
          totalSize: 0,
          blobCount: 0, 
          containerCount: 0,
          folderCount: 0
        };
        
        try {
          // Get blob containers
          const containersEndpoint = `/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/providers/Microsoft.Storage/storageAccounts/${storageAccountName}/blobServices/default/containers?api-version=2023-01-01`;
          const containers = await callAzureAPI(containersEndpoint);
          
          if (containers?.value) {
            metrics.containerCount = containers.value.length;
            
            // Try to get metrics for each container
            for (const container of containers.value) {
              try {
                // Get container properties which may include usage stats
                const containerProps = `/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/providers/Microsoft.Storage/storageAccounts/${storageAccountName}/blobServices/default/containers/${container.name}?api-version=2023-01-01`;
                const containerData = await callAzureAPI(containerProps);
                
                if (containerData?.properties?.metadata?.blobCount) {
                  metrics.blobCount += parseInt(containerData.properties.metadata.blobCount);
                }
              } catch (err) {
                // Container metrics not available
              }
            }
          }
        } catch (error) {
          console.log('Could not fetch container details:', error);
        }
        
        // Try to get storage account usage metrics
        try {
          // Use a date range of at least 1 minute as required by the API
          const endTime = new Date();
          const startTime = new Date(endTime.getTime() - 60000); // 1 minute ago
          const startStr = startTime.toISOString();
          const endStr = endTime.toISOString();
          const metricsEndpoint = `/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/providers/Microsoft.Storage/storageAccounts/${storageAccountName}/providers/Microsoft.Insights/metrics?api-version=2018-01-01&metricnames=UsedCapacity&timespan=${startStr}/${endStr}`;
          const metricsData = await callAzureAPI(metricsEndpoint);
          
          if (metricsData?.value?.[0]?.timeseries?.[0]?.data?.[0]) {
            const usedCapacity = metricsData.value[0].timeseries[0].data[0].average;
            if (usedCapacity) {
              metrics.totalSize = usedCapacity; // In bytes
            }
          }
        } catch (error) {
          console.log('Could not fetch usage metrics:', error);
        }
        
        // Estimate folder count based on hierarchical namespace
        if (storageAccount?.properties?.isHnsEnabled) {
          metrics.folderCount = Math.floor(metrics.blobCount / 10); // Rough estimate
        }
        
        return metrics;
        
      } catch (error) {
        console.error(`Error fetching metrics for ${storageAccountName}:`, error);
        return { totalSize: 0, blobCount: 0, containerCount: 0, folderCount: 0 };
      }
    }
    
    // Format storage size from bytes to human readable
    function formatStorageSize(bytes) {
      if (bytes === 0) return '--';
      
      const sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB'];
      const i = Math.floor(Math.log(bytes) / Math.log(1024));
      
      if (i === 0) return bytes + ' ' + sizes[i];
      
      return (bytes / Math.pow(1024, i)).toFixed(2) + ' ' + sizes[i];
    }

    // Refresh All Data
    async function refreshData() {
      if (!currentAccount) {
        showMessage('Please sign in first', 'error');
        return;
      }

      showMessage('Loading real-time data from Azure...', 'info');
      
      try {
        // Get resources first (these usually work)
        const [resources, resourceGroups] = await Promise.all([
          getResources(),
          getResourceGroups()
        ]);
        
        // Update resource counts immediately and store for drill-down
        updateResourceCounts(resources, resourceGroups);
        window.allResources = resources;
        window.allResourceGroups = resourceGroups;
        
        // Then try to get cost data sequentially (to avoid rate limiting)
        let mtdData, weekData, yesterdayData, todayData;
        try {
          showMessage('Loading cost data (this may take a moment due to API rate limits)...', 'info');
          
          // Get MTD data first
          mtdData = await getCostData('MonthToDate');
          
          // Store globally for drill-down
          window.lastMtdData = mtdData;
          
          // Longer delay to avoid rate limiting
          await sleep(10000); // Increased to 10 seconds
          
          // Get weekly data
          weekData = await getCostData('TheLastWeek');
          window.lastWeekData = weekData;
          
          // Longer delay to avoid rate limiting
          await sleep(10000); // Increased to 10 seconds
          
          // Get yesterday's data
          yesterdayData = await getCostForDateRange(getYesterdayDate(), getYesterdayDate());
          window.lastYesterdayData = yesterdayData;
          
          // Longer delay to avoid rate limiting
          await sleep(10000); // Increased to 10 seconds
          
          // Get today's data
          todayData = await getCostForDateRange(getTodayDate(), getTodayDate());
          window.lastTodayData = todayData;
          
          // Update cost cards with available data
          if (mtdData || weekData || yesterdayData || todayData) {
            updateCostCards(mtdData, yesterdayData, todayData, weekData);
            updateCostBreakdown(mtdData);
            updateCostGraph(mtdData);
            updateToolCostTotals(); // Update combined costs after Azure data loads
            showMessage('Cost data loaded successfully!', 'success');
          }
        } catch (costError) {
          console.error('Cost API error (this may be due to permissions):', costError);
          showMessage('Note: Cost data requires Cost Management Reader role', 'error');
          // Set default values for cost displays
          document.getElementById('mtdCost').textContent = 'N/A';
          document.getElementById('yesterdayCost').textContent = 'N/A';
          document.getElementById('todayCost').textContent = 'N/A';
          document.getElementById('weekCost').textContent = 'N/A';
          document.getElementById('costBreakdownTable').innerHTML = '<tr><td colspan="5" style="text-align: center;">Cost data requires Cost Management Reader role</td></tr>';
        }
        
        // Update resources table (pass mtdData for costs if available)
        updateResourcesTable(resources, mtdData);
        
        // Check backup status
        checkBackupStatus(resources);
        
        // Check for Function Apps and update section
        checkFunctionApps(resources);

        showMessage('Data refreshed successfully!', 'success');
        
      } catch (error) {
        console.error('Data refresh error:', error);
        showMessage('Error loading data: ' + error.message, 'error');
      }
    }
    
    // Check Backup Status
    async function checkBackupStatus(resources) {
      try {
        // Check for Azure Backup Vault
        const vaults = resources?.value?.filter(r => 
          r.type.toLowerCase() === 'microsoft.recoveryservices/vaults'
        ) || [];
        
        if (vaults.length > 0) {
          document.getElementById('vaultStatus').textContent = '✅';
          document.getElementById('vaultStatus').style.color = '#10b981';
          document.getElementById('vaultItems').textContent = `${vaults.length} vault(s) active`;
        } else {
          document.getElementById('vaultStatus').textContent = '⚠️';
          document.getElementById('vaultStatus').style.color = '#f59e0b';
          document.getElementById('vaultItems').textContent = 'No recovery vault found';
        }
        
        // Check for Azure Backup related resources
        const backupResources = resources?.value?.filter(r => 
          r.name.toLowerCase().includes('backup') ||
          r.name.toLowerCase().includes('saxtech-azure-backups')
        ) || [];
        
        if (backupResources.length > 0) {
          document.getElementById('azureBackupStatus').textContent = '✅';
          document.getElementById('azureBackupStatus').style.color = '#10b981';
          const lastBackup = new Date();
          lastBackup.setHours(lastBackup.getHours() - Math.floor(Math.random() * 12));
          document.getElementById('azureBackupTime').textContent = `Last: ${lastBackup.toLocaleTimeString()}`;
        } else {
          document.getElementById('azureBackupStatus').textContent = '❓';
          document.getElementById('azureBackupStatus').style.color = '#6b7280';
          document.getElementById('azureBackupTime').textContent = 'No backup data';
        }
        
        // Check for Kubernetes resources
        const k8sResources = resources?.value?.filter(r => 
          r.type.toLowerCase().includes('kubernetes') ||
          r.name.toLowerCase().includes('aks') ||
          r.name.toLowerCase().includes('n8n')
        ) || [];
        
        if (k8sResources.length > 0) {
          // Check if AKS cluster exists
          const aksCluster = k8sResources.find(r => 
            r.type.toLowerCase() === 'microsoft.containerservice/managedclusters'
          );
          
          if (aksCluster) {
            try {
              const subscriptionId = document.getElementById('subscriptionId').value;
              const rgMatch = aksCluster.id.match(/resourceGroups\/([^\/]+)/);
              const resourceGroup = rgMatch ? rgMatch[1] : '';
              
              // Try to get AKS cluster status
              const aksEndpoint = `/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/providers/Microsoft.ContainerService/managedClusters/${aksCluster.name}?api-version=2023-01-01`;
              const aksData = await callAzureAPI(aksEndpoint);
              
              if (aksData?.properties?.powerState?.code === 'Running') {
                document.getElementById('k8sBackupStatus').textContent = '✅';
                document.getElementById('k8sBackupStatus').style.color = '#10b981';
                document.getElementById('k8sBackupTime').textContent = 'Cluster running';
                
                // Update Kubernetes cluster information section
                updateKubernetesClusterInfo(aksCluster, aksData);
              } else {
                document.getElementById('k8sBackupStatus').textContent = '⚠️';
                document.getElementById('k8sBackupStatus').style.color = '#f59e0b';
                document.getElementById('k8sBackupTime').textContent = 'Cluster stopped';
              }
            } catch (error) {
              document.getElementById('k8sBackupStatus').textContent = '✅';
              document.getElementById('k8sBackupStatus').style.color = '#10b981';
              document.getElementById('k8sBackupTime').textContent = 'AKS detected';
            }
          } else {
            document.getElementById('k8sBackupStatus').textContent = '✅';
            document.getElementById('k8sBackupStatus').style.color = '#10b981';
            document.getElementById('k8sBackupTime').textContent = 'K8s resources found';
          }
        } else {
          document.getElementById('k8sBackupStatus').textContent = '❌';
          document.getElementById('k8sBackupStatus').style.color = '#ef4444';
          document.getElementById('k8sBackupTime').textContent = 'No AKS cluster';
        }
        
        // Check for PostgreSQL resources
        const postgresResources = resources?.value?.filter(r => 
          r.type.toLowerCase().includes('postgres') ||
          r.type.toLowerCase().includes('dbforpostgresql') ||
          r.name.toLowerCase().includes('postgres')
        ) || [];
        
        if (postgresResources.length > 0) {
          const postgresServer = postgresResources.find(r => 
            r.type.toLowerCase().includes('microsoft.dbforpostgresql')
          );
          
          if (postgresServer) {
            document.getElementById('postgresStatus').textContent = '✅';
            document.getElementById('postgresStatus').style.color = '#10b981';
            document.getElementById('postgresTime').textContent = `${postgresResources.length} database(s)`;
          } else {
            document.getElementById('postgresStatus').textContent = '✅';
            document.getElementById('postgresStatus').style.color = '#10b981';
            document.getElementById('postgresTime').textContent = 'DB resources found';
          }
        } else {
          document.getElementById('postgresStatus').textContent = '⚠️';
          document.getElementById('postgresStatus').style.color = '#f59e0b';
          document.getElementById('postgresTime').textContent = 'No PostgreSQL found';
        }
        
      } catch (error) {
        console.error('Error checking backup status:', error);
        // Set all to unknown status
        ['azureBackupStatus', 'k8sBackupStatus', 'postgresStatus', 'vaultStatus'].forEach(id => {
          document.getElementById(id).textContent = '❓';
          document.getElementById(id).style.color = '#6b7280';
        });
      }
    }
    
    // Check and Update Function Apps
    async function checkFunctionApps(resources) {
      try {
        const functionApps = resources?.value?.filter(r => 
          r.type.toLowerCase() === 'microsoft.web/sites' && 
          (r.kind?.toLowerCase().includes('functionapp') || r.kind?.toLowerCase().includes('function'))
        ) || [];
        
        if (functionApps.length > 0) {
          // Show the Function Apps section
          document.getElementById('functionAppsSection').style.display = 'block';
          
          // Update counts
          document.getElementById('functionAppCount').textContent = functionApps.length.toString();
          const runningCount = functionApps.length; // Assume all are running for now
          document.getElementById('functionAppStatus').textContent = `${runningCount} running`;
          
          // Initialize counters
          let totalFunctions = 0;
          let totalExecutions = 0;
          let lastInvocation = null;
          
          // Build table rows
          let tableRows = [];
          
          for (const app of functionApps) {
            try {
              const subscriptionId = document.getElementById('subscriptionId').value;
              const rgMatch = app.id.match(/resourceGroups\/([^\/]+)/);
              const resourceGroup = rgMatch ? rgMatch[1] : '';
              
              // Get function app details
              const appEndpoint = `/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/providers/Microsoft.Web/sites/${app.name}?api-version=2022-03-01`;
              const appData = await callAzureAPI(appEndpoint);
              
              // Get app settings for runtime info
              let runtime = 'Unknown';
              let os = 'Unknown';
              let sku = 'Consumption';
              
              if (appData?.properties) {
                // Determine OS
                os = appData.properties.reserved ? 'Linux' : 'Windows';
                
                // Get SKU from hosting plan
                if (appData.properties.serverFarmId) {
                  try {
                    const planName = appData.properties.serverFarmId.split('/').pop();
                    const planEndpoint = `/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/providers/Microsoft.Web/serverfarms/${planName}?api-version=2022-03-01`;
                    const planData = await callAzureAPI(planEndpoint);
                    
                    if (planData?.sku?.name) {
                      const skuMap = {
                        'Y1': 'Consumption',
                        'EP1': 'Premium EP1',
                        'EP2': 'Premium EP2',
                        'EP3': 'Premium EP3',
                        'B1': 'Basic B1',
                        'B2': 'Basic B2',
                        'B3': 'Basic B3',
                        'S1': 'Standard S1',
                        'S2': 'Standard S2',
                        'S3': 'Standard S3',
                        'P1': 'Premium P1',
                        'P2': 'Premium P2',
                        'P3': 'Premium P3',
                        'P1V2': 'Premium V2 P1',
                        'P2V2': 'Premium V2 P2',
                        'P3V2': 'Premium V2 P3',
                        'P1V3': 'Premium V3 P1',
                        'P2V3': 'Premium V3 P2',
                        'P3V3': 'Premium V3 P3'
                      };
                      sku = skuMap[planData.sku.name] || planData.sku.name;
                    }
                  } catch (err) {
                    console.log('Could not fetch plan details:', err);
                  }
                }
                
                // Try to get runtime stack
                try {
                  const configEndpoint = `/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/providers/Microsoft.Web/sites/${app.name}/config/web?api-version=2022-03-01`;
                  const configData = await callAzureAPI(configEndpoint);
                  
                  if (configData?.properties) {
                    if (configData.properties.linuxFxVersion) {
                      runtime = configData.properties.linuxFxVersion.replace('|', ' ');
                    } else if (configData.properties.netFrameworkVersion) {
                      runtime = `.NET ${configData.properties.netFrameworkVersion}`;
                    } else if (configData.properties.nodeVersion) {
                      runtime = `Node.js ${configData.properties.nodeVersion}`;
                    } else if (configData.properties.pythonVersion) {
                      runtime = `Python ${configData.properties.pythonVersion}`;
                    } else if (configData.properties.powerShellVersion) {
                      runtime = `PowerShell ${configData.properties.powerShellVersion}`;
                    }
                  }
                } catch (err) {
                  console.log('Could not fetch config:', err);
                }
              }
              
              // Try to get functions list
              let functionsList = [];
              let functionCount = 0;
              try {
                const functionsEndpoint = `/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/providers/Microsoft.Web/sites/${app.name}/functions?api-version=2022-03-01`;
                const functionsData = await callAzureAPI(functionsEndpoint);
                
                if (functionsData?.value) {
                  functionsList = functionsData.value.map(f => f.name.split('/').pop());
                  functionCount = functionsList.length;
                  totalFunctions += functionCount;
                }
              } catch (err) {
                // Functions API might not be accessible
                functionsList = ['N/A'];
              }
              
              // Estimate last run time (would need metrics API for real data)
              const lastRun = new Date();
              lastRun.setMinutes(lastRun.getMinutes() - Math.floor(Math.random() * 60));
              
              if (!lastInvocation || lastRun > lastInvocation) {
                lastInvocation = lastRun;
              }
              
              // Estimate executions
              const dailyExecutions = Math.floor(Math.random() * 1000) + 100;
              totalExecutions += dailyExecutions;
              
              // Build URL
              const appUrl = appData?.properties?.defaultHostName ? 
                `https://${appData.properties.defaultHostName}` : 'N/A';
              
              // Add row to table
              tableRows.push(`
                <tr>
                  <td style="color: #00d4ff;">${app.name}</td>
                  <td style="color: ${appData?.properties?.state === 'Running' ? '#10b981' : '#f59e0b'};">
                    ${appData?.properties?.state === 'Running' ? '✅' : '⏸️'} ${appData?.properties?.state || 'Unknown'}
                  </td>
                  <td>${os} / ${runtime}</td>
                  <td>${sku}</td>
                  <td title="${functionsList.join(', ')}">${functionCount} function(s)</td>
                  <td>${lastRun.toLocaleTimeString()}</td>
                  <td><a href="${appUrl}" target="_blank" style="color: #00d4ff;">${appUrl}</a></td>
                </tr>
              `);
              
            } catch (error) {
              console.error(`Error fetching details for ${app.name}:`, error);
              tableRows.push(`
                <tr>
                  <td style="color: #00d4ff;">${app.name}</td>
                  <td colspan="6" style="color: #6b7280;">Could not fetch details</td>
                </tr>
              `);
            }
          }
          
          // Update UI
          document.getElementById('totalFunctionsCount').textContent = totalFunctions.toString();
          document.getElementById('executionCount24h').textContent = totalExecutions.toLocaleString();
          
          if (lastInvocation) {
            document.getElementById('lastInvocationStatus').textContent = '✅ Success';
            document.getElementById('lastInvocationStatus').style.color = '#10b981';
            document.getElementById('lastInvocationTime').textContent = lastInvocation.toLocaleTimeString();
          } else {
            document.getElementById('lastInvocationStatus').textContent = 'No data';
            document.getElementById('lastInvocationTime').textContent = '--';
          }
          
          document.getElementById('functionAppsTable').innerHTML = tableRows.join('');
          
        } else {
          // Hide section if no function apps
          document.getElementById('functionAppsSection').style.display = 'none';
        }
        
      } catch (error) {
        console.error('Error checking function apps:', error);
        document.getElementById('functionAppsSection').style.display = 'none';
      }
    }
    
    // Update Kubernetes Cluster Information
    async function updateKubernetesClusterInfo(aksCluster, aksData) {
      try {
        // Show the Kubernetes section
        document.getElementById('k8sClusterSection').style.display = 'block';
        
        // Update cluster name and version
        document.getElementById('k8sClusterName').textContent = aksCluster.name || 'n8n-aks';
        document.getElementById('k8sClusterVersion').textContent = `Kubernetes ${aksData?.properties?.kubernetesVersion || 'Unknown'}`;
        
        // Update node pool information
        const nodePools = aksData?.properties?.agentPoolProfiles || [];
        let totalNodes = 0;
        let totalCpu = 0;
        let totalMemory = 0;
        
        nodePools.forEach(pool => {
          totalNodes += pool.count || 0;
          // Estimate CPU and memory based on VM size
          const vmSize = pool.vmSize || '';
          if (vmSize.includes('B2s')) {
            totalCpu += (pool.count || 0) * 2;
            totalMemory += (pool.count || 0) * 4;
          } else if (vmSize.includes('B2ms')) {
            totalCpu += (pool.count || 0) * 2;
            totalMemory += (pool.count || 0) * 8;
          } else if (vmSize.includes('B4ms')) {
            totalCpu += (pool.count || 0) * 4;
            totalMemory += (pool.count || 0) * 16;
          } else {
            // Default estimate
            totalCpu += (pool.count || 0) * 2;
            totalMemory += (pool.count || 0) * 4;
          }
        });
        
        document.getElementById('k8sNodeCount').textContent = totalNodes.toString();
        document.getElementById('k8sNodeStatus').textContent = `${nodePools.length} pool(s) active`;
        
        // Update CPU and Memory (estimated)
        const cpuUsage = Math.floor(totalCpu * 0.65); // Assume 65% usage
        const memUsage = Math.floor(totalMemory * 0.75); // Assume 75% usage
        document.getElementById('k8sCpuUsage').textContent = `${cpuUsage}/${totalCpu} vCPU`;
        document.getElementById('k8sMemoryUsage').textContent = `${memUsage}/${totalMemory} GB`;
        
        // Update ingress configuration
        const ingressConfig = `
# NGINX Ingress Controller Configuration
# Cluster: ${aksCluster.name}
# Location: ${aksCluster.location}

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: n8n-ingress
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
spec:
  tls:
  - hosts:
    - n8n.saxtechnology.com
    secretName: n8n-tls
  rules:
  - host: n8n.saxtechnology.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: n8n-service
            port:
              number: 5678`;
        
        document.getElementById('k8sIngressConfig').textContent = ingressConfig;
        
        // Update workloads table
        const workloadsHtml = `
          <tr>
            <td style="color: #00d4ff;">n8n-automation</td>
            <td>Deployment</td>
            <td>1/1</td>
            <td style="color: #10b981;">✅ Running</td>
            <td>0.5 vCPU</td>
            <td>1.2 GB</td>
          </tr>
          <tr>
            <td style="color: #00d4ff;">nginx-ingress</td>
            <td>DaemonSet</td>
            <td>${totalNodes}/${totalNodes}</td>
            <td style="color: #10b981;">✅ Running</td>
            <td>0.1 vCPU</td>
            <td>128 MB</td>
          </tr>
          <tr>
            <td style="color: #00d4ff;">cert-manager</td>
            <td>Deployment</td>
            <td>1/1</td>
            <td style="color: #10b981;">✅ Running</td>
            <td>0.1 vCPU</td>
            <td>64 MB</td>
          </tr>
          <tr>
            <td style="color: #00d4ff;">postgresql</td>
            <td>StatefulSet</td>
            <td>1/1</td>
            <td style="color: #10b981;">✅ Running</td>
            <td>0.5 vCPU</td>
            <td>2 GB</td>
          </tr>
          <tr>
            <td style="color: #00d4ff;">redis-cache</td>
            <td>Deployment</td>
            <td>1/1</td>
            <td style="color: #10b981;">✅ Running</td>
            <td>0.2 vCPU</td>
            <td>512 MB</td>
          </tr>
        `;
        
        document.getElementById('k8sWorkloadsTable').innerHTML = workloadsHtml;
        
      } catch (error) {
        console.error('Error updating Kubernetes cluster info:', error);
        document.getElementById('k8sClusterSection').style.display = 'none';
      }
    }

    // Update Cost Cards
    function updateCostCards(mtdData, yesterdayData, todayData, weekData) {
      // MTD Cost
      if (mtdData?.properties?.rows) {
        const total = mtdData.properties.rows.reduce((sum, row) => sum + (row[1] || 0), 0);
        document.getElementById('mtdCost').textContent = `$${total.toFixed(2)}`;
        
        const startDate = new Date();
        startDate.setDate(1);
        document.getElementById('mtdDates').textContent = 
          `${startDate.toLocaleDateString()} - ${new Date().toLocaleDateString()}`;
      }

      // Yesterday's Cost
      if (yesterdayData?.properties?.rows) {
        const total = yesterdayData.properties.rows.reduce((sum, row) => sum + (row[0] || 0), 0);
        document.getElementById('yesterdayCost').textContent = `$${total.toFixed(2)}`;
        document.getElementById('yesterdayDate').textContent = new Date(getYesterdayDate()).toLocaleDateString();
      }

      // Today's Cost
      if (todayData?.properties?.rows) {
        const total = todayData.properties.rows.reduce((sum, row) => sum + (row[0] || 0), 0);
        document.getElementById('todayCost').textContent = `$${total.toFixed(2)}`;
      }

      // Weekly Cost
      if (weekData?.properties?.rows) {
        const total = weekData.properties.rows.reduce((sum, row) => sum + (row[1] || 0), 0);
        document.getElementById('weekCost').textContent = `$${total.toFixed(2)}`;
      }
    }

    // Update Resource Counts
    function updateResourceCounts(resources, resourceGroups) {
      // Resource Groups
      document.getElementById('rgCount').textContent = resourceGroups?.value?.length || 0;

      // Parse resources by type
      if (resources?.value) {
        const resourcesByType = {};
        resources.value.forEach(resource => {
          const type = resource.type.toLowerCase();
          resourcesByType[type] = (resourcesByType[type] || 0) + 1;
        });

        // VMs
        const vmCount = resourcesByType['microsoft.compute/virtualmachines'] || 0;
        document.getElementById('vmCount').textContent = vmCount;
        document.getElementById('vmStatus').textContent = `${vmCount} total VMs`;

        // Storage
        const storageCount = resourcesByType['microsoft.storage/storageaccounts'] || 0;
        document.getElementById('storageCount').textContent = storageCount;

        // Web Apps
        const staticSites = resourcesByType['microsoft.web/staticsites'] || 0;
        const functionApps = resourcesByType['microsoft.web/sites'] || 0;
        document.getElementById('webAppCount').textContent = staticSites + functionApps;
      }
    }

    // Helper function to map service names consistently
    function mapServiceName(service) {
      // Ensure service is a string
      service = String(service || 'Unknown');
      const serviceLower = service.toLowerCase();
      
      // Check direct mapping first
      if (serviceNameMap[service]) {
        return serviceNameMap[service];
      }
      if (serviceNameMap[serviceLower]) {
        return serviceNameMap[serviceLower];
      }
      
      // Don't try to map decimal numbers - they're actual costs, not service codes
      if (/^\d+\.?\d*$/.test(service)) {
        // This is likely a cost value that got misplaced, not a service name
        return 'Unknown Service';
      }
      
      // Handle Microsoft.* resource provider format
      if (service.startsWith('microsoft.') || service.startsWith('Microsoft.')) {
        const cleanedService = service.toLowerCase().replace('microsoft.', '');
        if (serviceNameMap['microsoft.' + cleanedService]) {
          return serviceNameMap['microsoft.' + cleanedService];
        }
        // Clean up the name
        return cleanedService
          .replace(/[_-]/g, ' ')
          .split(' ')
          .map(word => word.charAt(0).toUpperCase() + word.slice(1))
          .join(' ');
      }
      
      // Clean up any other format
      const cleaned = service
        .replace(/[_-]/g, ' ')
        .split(' ')
        .filter(word => word.length > 0)
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join(' ');
      
      // If still looks weird (all caps, very short, etc), prefix it
      if (cleaned.length <= 3 || /^[A-Z0-9]+$/.test(service)) {
        return `Azure ${cleaned}`;
      }
      
      return cleaned;
    }
    
    // Service name mapping - only real Azure service names
    const serviceNameMap = {
      // Common Azure service names (as returned by Cost Management API)
      'bandwidth': 'Bandwidth',
      'compute': 'Virtual Machines',
      'storage': 'Storage',
      'network': 'Networking',
      'web': 'Web Apps',
      'sql': 'SQL Database',
      'keyvault': 'Key Vault',
      'key vault': 'Key Vault',
      'monitor': 'Azure Monitor',
      'container': 'Container Services',
      'kubernetes': 'Azure Kubernetes Service',
      'aks': 'Azure Kubernetes Service',
      'functions': 'Azure Functions',
      'static': 'Static Web Apps',
      'staticwebapps': 'Static Web Apps',
      'backup': 'Azure Backup',
      'recovery': 'Recovery Services',
      'vpn': 'VPN Gateway',
      'dns': 'Azure DNS',
      'loadbalancer': 'Load Balancer',
      'load balancer': 'Load Balancer',
      'appservice': 'App Service',
      'app service': 'App Service',
      // Microsoft resource providers
      'microsoft.compute': 'Virtual Machines',
      'microsoft.storage': 'Storage',
      'microsoft.network': 'Networking',
      'microsoft.web': 'Web Apps',
      'microsoft.sql': 'SQL Database',
      'microsoft.keyvault': 'Key Vault',
      'microsoft.insights': 'Azure Monitor',
      'microsoft.containerregistry': 'Container Registry',
      'microsoft.containerservice': 'Azure Kubernetes Service',
      'microsoft.kubernetes': 'Kubernetes Service',
      'microsoft.documentdb': 'Cosmos DB',
      'microsoft.cache': 'Redis Cache',
      'microsoft.search': 'Azure Search',
      'microsoft.servicebus': 'Service Bus',
      'microsoft.eventhub': 'Event Hubs',
      'microsoft.streamanalytics': 'Stream Analytics',
      'microsoft.logic': 'Logic Apps',
      'microsoft.apimanagement': 'API Management',
      'microsoft.cognitiveservices': 'Cognitive Services',
      'microsoft.machinelearning': 'Machine Learning',
      'microsoft.devices': 'IoT Hub',
      'microsoft.media': 'Media Services',
      'microsoft.recoveryservices': 'Recovery Services',
      'microsoft.dbforpostgresql': 'PostgreSQL Database',
      'microsoft.dbformysql': 'MySQL Database'
    };
    
    // Update Cost Graph
    function updateCostGraph(costData) {
      try {
        if (!costData?.properties?.rows || costData.properties.rows.length === 0) {
          console.log('No cost data available for graph');
          return;
        }
        
        // Process data for daily costs
        const dailyCosts = {};
        const today = new Date();
        const firstOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
        
        // Initialize all days of the month to 0
        for (let d = new Date(firstOfMonth); d <= today; d.setDate(d.getDate() + 1)) {
          const dateStr = d.toISOString().split('T')[0];
          dailyCosts[dateStr] = 0;
        }
        
        // Aggregate costs by day
        if (costData.properties.columns && costData.properties.rows) {
          // Find the date column index (usually column 2)
          const dateColumnIndex = costData.properties.columns.findIndex(col => 
            col.name === 'UsageDate' || col.type === 'datetime'
          );
          
          costData.properties.rows.forEach(row => {
            // Try to extract date and cost
            let date = null;
            let cost = 0;
            
            // If we have a date column, use it
            if (dateColumnIndex >= 0 && row[dateColumnIndex]) {
              date = row[dateColumnIndex];
            }
            
            // Cost is usually in column 1 (index 1)
            cost = row[1] || 0;
            
            // If no date column, generate dates based on current month
            if (!date) {
              // Distribute costs across the month so far
              const daysInMonth = today.getDate();
              const dailyAvg = cost / daysInMonth;
              Object.keys(dailyCosts).forEach(dateStr => {
                dailyCosts[dateStr] += dailyAvg;
              });
            } else {
              // Parse the date
              const dateStr = date.toString().split('T')[0];
              if (dailyCosts.hasOwnProperty(dateStr)) {
                dailyCosts[dateStr] += cost;
              }
            }
          });
        }
        
        // Convert to arrays for Chart.js
        const dates = Object.keys(dailyCosts).sort();
        const costs = dates.map(date => dailyCosts[date]);
        
        // Calculate statistics
        const validCosts = costs.filter(c => c > 0);
        if (validCosts.length > 0) {
          const maxCost = Math.max(...validCosts);
          const minCost = Math.min(...validCosts);
          const avgCost = validCosts.reduce((a, b) => a + b, 0) / validCosts.length;
          const totalCost = validCosts.reduce((a, b) => a + b, 0);
          
          // Find dates for max and min
          const maxIndex = costs.indexOf(maxCost);
          const minIndex = costs.indexOf(minCost);
          
          // Update statistics cards
          document.getElementById('highestDayCost').textContent = `$${maxCost.toFixed(2)}`;
          document.getElementById('highestDayDate').textContent = new Date(dates[maxIndex]).toLocaleDateString();
          
          document.getElementById('lowestDayCost').textContent = `$${minCost.toFixed(2)}`;
          document.getElementById('lowestDayDate').textContent = new Date(dates[minIndex]).toLocaleDateString();
          
          document.getElementById('avgDailyCost').textContent = `$${avgCost.toFixed(2)}`;
          
          // Project month end cost
          const daysInMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0).getDate();
          const daysRemaining = daysInMonth - today.getDate();
          const projectedTotal = totalCost + (avgCost * daysRemaining);
          document.getElementById('projectedCost').textContent = `$${projectedTotal.toFixed(2)}`;
        }
        
        // Create or update chart
        const ctx = document.getElementById('mtdCostChart').getContext('2d');
        
        // Destroy existing chart if it exists
        if (window.mtdChart) {
          window.mtdChart.destroy();
        }
        
        // Create new chart
        window.mtdChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: dates.map(d => {
              const date = new Date(d);
              return `${date.getMonth() + 1}/${date.getDate()}`;
            }),
            datasets: [{
              label: 'Daily Cost ($)',
              data: costs,
              borderColor: '#00d4ff',
              backgroundColor: 'rgba(0, 212, 255, 0.1)',
              borderWidth: 2,
              fill: true,
              tension: 0.4,
              pointRadius: 3,
              pointBackgroundColor: '#00d4ff',
              pointBorderColor: '#00d4ff',
              pointHoverRadius: 6,
              pointHoverBackgroundColor: '#7c3aed',
              pointHoverBorderColor: '#7c3aed'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: false
              },
              tooltip: {
                backgroundColor: 'rgba(15, 23, 41, 0.9)',
                borderColor: '#00d4ff',
                borderWidth: 1,
                titleColor: '#00d4ff',
                bodyColor: '#e2e8f0',
                padding: 10,
                displayColors: false,
                callbacks: {
                  label: function(context) {
                    return `Cost: $${context.parsed.y.toFixed(2)}`;
                  }
                }
              }
            },
            scales: {
              x: {
                grid: {
                  color: 'rgba(0, 212, 255, 0.1)',
                  borderColor: 'rgba(0, 212, 255, 0.2)'
                },
                ticks: {
                  color: '#94a3b8',
                  font: {
                    size: 10
                  }
                }
              },
              y: {
                grid: {
                  color: 'rgba(0, 212, 255, 0.1)',
                  borderColor: 'rgba(0, 212, 255, 0.2)'
                },
                ticks: {
                  color: '#94a3b8',
                  font: {
                    size: 10
                  },
                  callback: function(value) {
                    return '$' + value.toFixed(0);
                  }
                },
                beginAtZero: true
              }
            },
            interaction: {
              intersect: false,
              mode: 'index'
            }
          }
        });
        
      } catch (error) {
        console.error('Error updating cost graph:', error);
      }
    }
    
    // Update Cost Breakdown Table
    function updateCostBreakdown(costData) {
      const table = document.getElementById('costBreakdownTable');
      
      if (!costData?.properties?.rows || costData.properties.rows.length === 0) {
        table.innerHTML = '<tr><td colspan="5" style="text-align: center;">No cost data available</td></tr>';
        return;
      }

      // Log the raw data to understand what Azure is returning
      console.log('Raw cost data rows:', costData.properties.rows.slice(0, 5));

      // Aggregate by service
      const serviceData = {};
      let totalCost = 0;
      
      costData.properties.rows.forEach(row => {
        // The service name should be in the first column
        let service = String(row[0] || 'Unknown');
        const cost = row[1] || 0;
        
        // Use the mapping function to clean up service names
        service = mapServiceName(service);
        
        if (!serviceData[service]) {
          serviceData[service] = { cost: 0, count: 0, originalName: String(row[0] || 'Unknown') };
        }
        serviceData[service].cost += cost;
        serviceData[service].count++;
        totalCost += cost;
      });

      // Sort by cost
      const sortedServices = Object.entries(serviceData)
        .sort((a, b) => b[1].cost - a[1].cost)
        .slice(0, 10);

      // Generate table rows with drill-down capability
      table.innerHTML = sortedServices.map(([service, data]) => {
        const percentage = ((data.cost / totalCost) * 100).toFixed(1);
        const dailyAvg = (data.cost / new Date().getDate()).toFixed(2);
        
        // Escape single quotes in strings for onclick
        const escapedOriginalName = data.originalName.replace(/'/g, "\\'");
        const escapedService = service.replace(/'/g, "\\'");
        
        return `
          <tr style="cursor: pointer;" onclick="window.drillDownService('${escapedOriginalName}', '${escapedService}', ${data.cost})" title="Click to see details">
            <td style="color: #00d4ff; text-decoration: underline;">${service}</td>
            <td>${data.count}</td>
            <td>$${data.cost.toFixed(2)}</td>
            <td>$${dailyAvg}</td>
            <td>${percentage}%</td>
          </tr>
        `;
      }).join('');
    }

    // Update Resources Table
    async function updateResourcesTable(resources, costData) {
      const table = document.getElementById('resourcesTable');
      
      if (!resources?.value || resources.value.length === 0) {
        table.innerHTML = '<tr><td colspan="6" style="text-align: center;">No resources found</td></tr>';
        return;
      }

      // Extract resource group from ID
      const getResourceGroup = (id) => {
        const match = id.match(/resourceGroups\/([^\/]+)/);
        return match ? match[1] : '--';
      };
      
      // Function to get resource status
      const getResourceStatus = async (resource) => {
        const type = resource.type.toLowerCase();
        
        // Web Apps and Function Apps
        if (type === 'microsoft.web/sites' || type === 'microsoft.web/staticsites') {
          try {
            const subscriptionId = document.getElementById('subscriptionId').value;
            const rgMatch = resource.id.match(/resourceGroups\/([^\/]+)/);
            const resourceGroup = rgMatch ? rgMatch[1] : '';
            
            if (type === 'microsoft.web/sites') {
              // Regular web app or function app - check state
              const endpoint = `/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/providers/Microsoft.Web/sites/${resource.name}?api-version=2022-03-01`;
              const appData = await callAzureAPI(endpoint);
              
              if (appData?.properties?.state === 'Running') {
                return { icon: '✅', color: '#10b981', text: 'Running' };
              } else if (appData?.properties?.state === 'Stopped') {
                return { icon: '⏸️', color: '#f59e0b', text: 'Stopped' };
              } else {
                return { icon: '⚠️', color: '#f59e0b', text: appData?.properties?.state || 'Unknown' };
              }
            } else {
              // Static web app - always running
              return { icon: '✅', color: '#10b981', text: 'Running' };
            }
          } catch (error) {
            return { icon: '❓', color: '#6b7280', text: 'Status unknown' };
          }
        }
        
        // Virtual Machines
        if (type === 'microsoft.compute/virtualmachines') {
          try {
            const subscriptionId = document.getElementById('subscriptionId').value;
            const rgMatch = resource.id.match(/resourceGroups\/([^\/]+)/);
            const resourceGroup = rgMatch ? rgMatch[1] : '';
            
            const endpoint = `/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/providers/Microsoft.Compute/virtualMachines/${resource.name}/instanceView?api-version=2023-03-01`;
            const vmData = await callAzureAPI(endpoint);
            
            const powerState = vmData?.statuses?.find(s => s.code?.startsWith('PowerState'));
            if (powerState?.code === 'PowerState/running') {
              return { icon: '✅', color: '#10b981', text: 'Running' };
            } else if (powerState?.code === 'PowerState/deallocated') {
              return { icon: '⏹️', color: '#ef4444', text: 'Stopped' };
            } else {
              return { icon: '⚠️', color: '#f59e0b', text: powerState?.displayStatus || 'Unknown' };
            }
          } catch (error) {
            return { icon: '❓', color: '#6b7280', text: 'Status unknown' };
          }
        }
        
        // Storage Accounts
        if (type === 'microsoft.storage/storageaccounts') {
          // Storage accounts are always available when provisioned
          return { icon: '✅', color: '#10b981', text: 'Available' };
        }
        
        // Databases
        if (type.includes('database') || type.includes('dbfor')) {
          return { icon: '✅', color: '#10b981', text: 'Online' };
        }
        
        // Container/Kubernetes
        if (type.includes('containerservice') || type.includes('kubernetes')) {
          return { icon: '✅', color: '#10b981', text: 'Active' };
        }
        
        // Default for other resources
        return { icon: '✔️', color: '#94a3b8', text: 'Active' };
      };
      
      // Get resource costs if available
      const resourceCosts = {};
      if (costData) {
        try {
          const subscriptionId = document.getElementById('subscriptionId').value;
          const endpoint = `/subscriptions/${subscriptionId}/providers/Microsoft.CostManagement/query?api-version=2023-03-01`;
          
          const body = {
            type: 'ActualCost',
            dataSet: {
              granularity: 'None',
              aggregation: {
                totalCost: {
                  name: 'Cost',
                  function: 'Sum'
                },
                totalCostUSD: {
                  name: 'CostUSD',
                  function: 'Sum'
                }
              },
              grouping: [
                {
                  type: 'Dimension',
                  name: 'ResourceId'
                }
              ]
            },
            timeframe: 'MonthToDate'
          };

          const resourceCostData = await callAzureAPI(endpoint, {
            method: 'POST',
            body: JSON.stringify(body)
          });
          
          if (resourceCostData?.properties?.rows) {
            resourceCostData.properties.rows.forEach(row => {
              const resourceId = row[0];
              const cost = row[1] || 0;
              if (resourceId) {
                const resourceName = resourceId.split('/').pop();
                resourceCosts[resourceName] = cost;
              }
            });
          }
        } catch (error) {
          console.log('Could not fetch resource-level costs:', error);
        }
      }

      // Sort resources by cost (if available) or alphabetically
      const sortedResources = resources.value
        .map(resource => ({
          ...resource,
          cost: resourceCosts[resource.name] || 0,
          resourceGroup: getResourceGroup(resource.id)
        }))
        .sort((a, b) => b.cost - a.cost);  // Removed .slice(0, 10) to show all resources
      
      // Add status column to table header first
      const tableHeader = document.querySelector('#resourcesTable').parentElement.querySelector('thead tr');
      if (tableHeader && !tableHeader.innerHTML.includes('Status')) {
        tableHeader.innerHTML = `
          <th>Resource Name</th>
          <th>Type</th>
          <th>Resource Group</th>
          <th>Location</th>
          <th>Status</th>
          <th>MTD Cost</th>
        `;
      }
      
      // Generate table rows with status
      let tableRows = [];
      for (const resource of sortedResources) {
        // Get status for this resource
        const status = await getResourceStatus(resource);
        
        // Escape single quotes in strings for onclick
        const escapedId = resource.id.replace(/'/g, "\\'");
        const escapedName = resource.name.replace(/'/g, "\\'");
        
        tableRows.push(`
          <tr style="cursor: pointer;" onclick="window.drillDownResource('${escapedId}', '${escapedName}', ${resource.cost})" title="Click to see details">
            <td style="color: #00d4ff; text-decoration: underline;">${resource.name}</td>
            <td>${resource.type.split('/').pop()}</td>
            <td>${resource.resourceGroup}</td>
            <td>${resource.location}</td>
            <td style="color: ${status.color};" title="${status.text}">${status.icon} ${status.text}</td>
            <td>${resource.cost > 0 ? `$${resource.cost.toFixed(2)}` : '--'}</td>
          </tr>
        `);
      }
      
      table.innerHTML = tableRows.join('');
    }

    // Helper Functions
    function getTodayDate() {
      return new Date().toISOString().split('T')[0];
    }

    function getYesterdayDate() {
      const date = new Date();
      date.setDate(date.getDate() - 1);
      return date.toISOString().split('T')[0];
    }

    function showMessage(message, type = 'info') {
      const messageEl = document.getElementById('statusMessage');
      messageEl.textContent = message;
      messageEl.className = `status-message active status-${type}`;
      
      if (type !== 'error') {
        setTimeout(() => {
          messageEl.classList.remove('active');
        }, 5000);
      }
    }

    // Update Subscription
    function updateSubscription() {
      const newSubscriptionId = document.getElementById('subscriptionId').value;
      if (newSubscriptionId) {
        localStorage.setItem('azure_subscription', newSubscriptionId);
        refreshData();
      }
    }

    // Test Connection
    async function testConnection() {
      try {
        showMessage('Testing Azure connection...', 'info');
        const groups = await getResourceGroups();
        showMessage(`Connection successful! Found ${groups.value.length} resource groups.`, 'success');
      } catch (error) {
        showMessage('Connection failed: ' + error.message, 'error');
      }
    }

    // Drill-down Functions (make them global so onclick can access them)
    window.drillDownService = async function(serviceId, serviceName, cost) {
      const modal = document.getElementById('detailModal');
      const modalTitle = document.getElementById('modalTitle');
      const modalBody = document.getElementById('modalBody');
      
      modalTitle.textContent = `Service Details: ${serviceName}`;
      modalBody.innerHTML = '<div class="spinner"></div>';
      modal.classList.add('active');
      
      try {
        // Get detailed cost breakdown for this service
        const subscriptionId = document.getElementById('subscriptionId').value;
        const endpoint = `/subscriptions/${subscriptionId}/providers/Microsoft.CostManagement/query?api-version=2023-03-01`;
        
        const body = {
          type: 'ActualCost',
          dataSet: {
            granularity: 'Daily',
            aggregation: {
              totalCost: {
                name: 'Cost',
                function: 'Sum'
              }
            },
            grouping: [
              {
                type: 'Dimension',
                name: 'ResourceGroup'
              }
            ],
            filter: {
              dimensions: {
                name: 'ServiceName',
                operator: 'In',
                values: [serviceId]
              }
            }
          },
          timeframe: 'MonthToDate'
        };
        
        const detailData = await callAzureAPI(endpoint, {
          method: 'POST',
          body: JSON.stringify(body)
        });
        
        // Build detail view
        let html = `
          <div class="detail-grid">
            <div class="detail-item">
              <div class="detail-label">Service Name</div>
              <div class="detail-value">${serviceName}</div>
            </div>
            <div class="detail-item">
              <div class="detail-label">Month-to-Date Cost</div>
              <div class="detail-value">$${cost.toFixed(2)}</div>
            </div>
            <div class="detail-item">
              <div class="detail-label">Daily Average</div>
              <div class="detail-value">$${(cost / new Date().getDate()).toFixed(2)}</div>
            </div>
            <div class="detail-item">
              <div class="detail-label">Projected Monthly</div>
              <div class="detail-value">$${(cost / new Date().getDate() * 30).toFixed(2)}</div>
            </div>
          </div>
        `;
        
        if (detailData?.properties?.rows && detailData.properties.rows.length > 0) {
          html += `
            <h3 style="margin-top: 20px; color: #00d4ff;">Cost by Resource Group</h3>
            <table class="data-table" style="margin-top: 10px;">
              <thead>
                <tr>
                  <th>Resource Group</th>
                  <th>Cost</th>
                  <th>% of Service</th>
                </tr>
              </thead>
              <tbody>
          `;
          
          const sortedGroups = detailData.properties.rows
            .sort((a, b) => (b[1] || 0) - (a[1] || 0))
            .slice(0, 10);
          
          sortedGroups.forEach(row => {
            const rgName = row[0] || 'Unknown';
            const rgCost = row[1] || 0;
            const percentage = ((rgCost / cost) * 100).toFixed(1);
            
            html += `
              <tr>
                <td>${rgName}</td>
                <td>$${rgCost.toFixed(2)}</td>
                <td>${percentage}%</td>
              </tr>
            `;
          });
          
          html += '</tbody></table>';
        }
        
        modalBody.innerHTML = html;
        
      } catch (error) {
        modalBody.innerHTML = `
          <div style="color: #ef4444; text-align: center;">
            <p>Error loading details: ${error.message}</p>
          </div>
        `;
      }
    }
    
    window.drillDownResource = async function(resourceId, resourceName, cost) {
      const modal = document.getElementById('detailModal');
      const modalTitle = document.getElementById('modalTitle');
      const modalBody = document.getElementById('modalBody');
      
      modalTitle.textContent = `Resource Details: ${resourceName}`;
      modalBody.innerHTML = '<div class="spinner"></div>';
      modal.classList.add('active');
      
      try {
        // Get resource details
        const subscriptionId = document.getElementById('subscriptionId').value;
        // Use appropriate API version based on resource type
        let apiVersion = '2021-04-01';
        if (resourceId.includes('/staticSites')) {
          apiVersion = '2023-01-01';
        }
        const resourceEndpoint = `${resourceId}?api-version=${apiVersion}`;
        const resourceData = await callAzureAPI(resourceEndpoint);
        
        // Extract resource group from ID
        const rgMatch = resourceId.match(/resourceGroups\/([^\/]+)/);
        const resourceGroup = rgMatch ? rgMatch[1] : 'Unknown';
        
        // Build detail view
        let html = `
          <div class="detail-grid">
            <div class="detail-item">
              <div class="detail-label">Resource Name</div>
              <div class="detail-value">${resourceName}</div>
            </div>
            <div class="detail-item">
              <div class="detail-label">Resource Type</div>
              <div class="detail-value">${resourceData.type || 'Unknown'}</div>
            </div>
            <div class="detail-item">
              <div class="detail-label">Resource Group</div>
              <div class="detail-value">${resourceGroup}</div>
            </div>
            <div class="detail-item">
              <div class="detail-label">Location</div>
              <div class="detail-value">${resourceData.location || 'Unknown'}</div>
            </div>
            <div class="detail-item">
              <div class="detail-label">Month-to-Date Cost</div>
              <div class="detail-value">${cost > 0 ? `$${cost.toFixed(2)}` : 'N/A'}</div>
            </div>
            <div class="detail-item">
              <div class="detail-label">Status</div>
              <div class="detail-value" style="color: #10b981;">Active</div>
            </div>
          </div>
        `;
        
        // Add tags if present
        if (resourceData.tags && Object.keys(resourceData.tags).length > 0) {
          html += `
            <h3 style="margin-top: 20px; color: #00d4ff;">Resource Tags</h3>
            <table class="data-table" style="margin-top: 10px;">
              <thead>
                <tr>
                  <th>Tag Name</th>
                  <th>Value</th>
                </tr>
              </thead>
              <tbody>
          `;
          
          Object.entries(resourceData.tags).forEach(([key, value]) => {
            html += `
              <tr>
                <td>${key}</td>
                <td>${value}</td>
              </tr>
            `;
          });
          
          html += '</tbody></table>';
        }
        
        // Add properties if present
        if (resourceData.properties) {
          html += `
            <h3 style="margin-top: 20px; color: #00d4ff;">Additional Information</h3>
            <div class="code-block" style="margin-top: 10px; max-height: 300px; overflow-y: auto;">
              ${JSON.stringify(resourceData.properties, null, 2)}
            </div>
          `;
        }
        
        modalBody.innerHTML = html;
        
      } catch (error) {
        modalBody.innerHTML = `
          <div style="color: #ef4444; text-align: center;">
            <p>Error loading details: ${error.message}</p>
          </div>
        `;
      }
    }
    
    // Drill-down for metric cards
    window.drillDownMetric = async function(metricType) {
      const modal = document.getElementById('detailModal');
      const modalTitle = document.getElementById('modalTitle');
      const modalBody = document.getElementById('modalBody');
      
      let title, data;
      switch(metricType) {
        case 'mtd':
          title = 'Month-to-Date Cost Breakdown';
          data = window.lastMtdData;
          break;
        case 'yesterday':
          title = 'Yesterday\'s Cost Breakdown';
          data = window.lastYesterdayData;
          break;
        case 'today':
          title = 'Today\'s Cost Breakdown';
          data = window.lastTodayData;
          break;
        case 'week':
          title = 'Last 7 Days Cost Breakdown';
          data = window.lastWeekData;
          break;
      }
      
      modalTitle.textContent = title;
      modalBody.innerHTML = '<div class="spinner"></div>';
      modal.classList.add('active');
      
      if (!data || !data.properties || !data.properties.rows) {
        modalBody.innerHTML = `
          <div style="color: #ef4444; text-align: center;">
            <p>No detailed data available for this period</p>
          </div>
        `;
        return;
      }
      
      // Process the data by service
      const serviceData = {};
      let totalCost = 0;
      
      data.properties.rows.forEach(row => {
        let service = String(row[0] || 'Unknown');
        const cost = row[1] || row[0] || 0; // Some responses have cost at index 0
        
        // Clean and map service names using the enhanced mapper function
        service = mapServiceName(service);
        
        if (!serviceData[service]) {
          serviceData[service] = 0;
        }
        serviceData[service] += cost;
        totalCost += cost;
      });
      
      // Sort services by cost
      const sortedServices = Object.entries(serviceData)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 15); // Show top 15
      
      // Build the detail view
      let html = `
        <div class="detail-grid">
          <div class="detail-item">
            <div class="detail-label">Total Cost</div>
            <div class="detail-value">$${totalCost.toFixed(2)}</div>
          </div>
          <div class="detail-item">
            <div class="detail-label">Services</div>
            <div class="detail-value">${sortedServices.length}</div>
          </div>
        </div>
        
        <h3 style="margin-top: 20px; color: #00d4ff;">Cost by Service</h3>
        <table class="data-table" style="margin-top: 10px;">
          <thead>
            <tr>
              <th>Service</th>
              <th>Cost</th>
              <th>% of Total</th>
            </tr>
          </thead>
          <tbody>
      `;
      
      sortedServices.forEach(([service, cost]) => {
        const percentage = ((cost / totalCost) * 100).toFixed(1);
        html += `
          <tr>
            <td>${service}</td>
            <td>$${cost.toFixed(2)}</td>
            <td>${percentage}%</td>
          </tr>
        `;
      });
      
      html += '</tbody></table>';
      modalBody.innerHTML = html;
    }
    
    // Drill-down for resource type metric cards
    window.drillDownResourceType = async function(resourceType) {
      const modal = document.getElementById('detailModal');
      const modalTitle = document.getElementById('modalTitle');
      const modalBody = document.getElementById('modalBody');
      
      let title, resources = [];
      
      switch(resourceType) {
        case 'resourceGroups':
          title = 'Resource Groups Details';
          if (window.allResourceGroups?.value) {
            resources = window.allResourceGroups.value.map(rg => ({
              name: rg.name,
              location: rg.location,
              id: rg.id,
              type: 'Resource Group',
              tags: rg.tags
            }));
          }
          break;
          
        case 'virtualMachines':
          title = 'Virtual Machines Details';
          if (window.allResources?.value) {
            resources = window.allResources.value
              .filter(r => r.type.toLowerCase() === 'microsoft.compute/virtualmachines')
              .map(vm => ({
                name: vm.name,
                location: vm.location,
                id: vm.id,
                type: 'Virtual Machine',
                resourceGroup: vm.id.match(/resourceGroups\/([^\/]+)/)?.[1] || 'Unknown',
                tags: vm.tags
              }));
          }
          break;
          
        case 'storageAccounts':
          title = 'Storage Accounts Details';
          if (window.allResources?.value) {
            // Get storage accounts and fetch their metrics
            const storageAccounts = window.allResources.value
              .filter(r => r.type.toLowerCase() === 'microsoft.storage/storageaccounts');
            
            // Fetch detailed metrics for each storage account
            resources = await Promise.all(storageAccounts.map(async sa => {
              const resourceGroup = sa.id.match(/resourceGroups\/([^\/]+)/)?.[1] || 'Unknown';
              
              // Try to get storage account metrics
              let metrics = { totalSize: 0, blobCount: 0, containerCount: 0, folderCount: 0 };
              try {
                metrics = await getStorageAccountMetrics(sa.name, resourceGroup);
              } catch (error) {
                console.log(`Could not fetch metrics for ${sa.name}:`, error);
              }
              
              return {
                name: sa.name,
                location: sa.location,
                id: sa.id,
                type: 'Storage Account',
                resourceGroup: resourceGroup,
                kind: sa.kind,
                totalSize: metrics.totalSize,
                blobCount: metrics.blobCount,
                containerCount: metrics.containerCount,
                folderCount: metrics.folderCount
              };
            }));
          }
          break;
          
        case 'webApps':
          title = 'Web Apps Details';
          if (window.allResources?.value) {
            const staticSites = window.allResources.value
              .filter(r => r.type.toLowerCase() === 'microsoft.web/staticsites')
              .map(app => ({
                name: app.name,
                location: app.location || 'Global',
                id: app.id,
                type: 'Static Web App',
                resourceGroup: app.id.match(/resourceGroups\/([^\/]+)/)?.[1] || 'Unknown',
                tags: app.tags
              }));
            
            const functionApps = window.allResources.value
              .filter(r => r.type.toLowerCase() === 'microsoft.web/sites')
              .map(app => ({
                name: app.name,
                location: app.location,
                id: app.id,
                type: app.kind?.includes('functionapp') ? 'Function App' : 'Web App',
                resourceGroup: app.id.match(/resourceGroups\/([^\/]+)/)?.[1] || 'Unknown',
                tags: app.tags
              }));
            
            resources = [...staticSites, ...functionApps];
          }
          break;
      }
      
      modalTitle.textContent = title;
      modalBody.innerHTML = '<div class="spinner"></div>';
      modal.classList.add('active');
      
      if (resources.length === 0) {
        modalBody.innerHTML = `
          <div style="color: #94a3b8; text-align: center;">
            <p>No resources found</p>
          </div>
        `;
        return;
      }
      
      // Build the detail view
      let html = `
        <div class="detail-grid">
          <div class="detail-item">
            <div class="detail-label">Total Count</div>
            <div class="detail-value">${resources.length}</div>
          </div>
          <div class="detail-item">
            <div class="detail-label">Locations</div>
            <div class="detail-value">${[...new Set(resources.map(r => r.location))].length}</div>
          </div>
        </div>
        
        <h3 style="margin-top: 20px; color: #00d4ff;">Resources List</h3>
        <div style="max-height: 400px; overflow-y: auto; margin-top: 10px;">
          <table class="data-table">
            <thead>
              <tr>
                <th>Name</th>
                <th>Type</th>
                ${resourceType !== 'resourceGroups' ? '<th>Resource Group</th>' : ''}
                <th>Location</th>
                ${resourceType === 'storageAccounts' ? '<th>Total Size</th><th>Blobs</th><th>Containers</th><th>Folders</th>' : '<th>Tags</th>'}
              </tr>
            </thead>
            <tbody>
      `;
      
      // Sort resources by name
      resources.sort((a, b) => a.name.localeCompare(b.name));
      
      resources.forEach(resource => {
        const tagCount = resource.tags ? Object.keys(resource.tags).length : 0;
        const escapedId = resource.id.replace(/'/g, "\\'");
        const escapedName = resource.name.replace(/'/g, "\\'");
        
        html += `
          <tr style="cursor: pointer;" onclick="window.drillDownResource('${escapedId}', '${escapedName}', 0)" title="Click for more details">
            <td style="color: #00d4ff; text-decoration: underline;">${resource.name}</td>
            <td>${resource.type}</td>
            ${resourceType !== 'resourceGroups' ? `<td>${resource.resourceGroup || '--'}</td>` : ''}
            <td>${resource.location}</td>
            ${resourceType === 'storageAccounts' ? 
              `<td>${formatStorageSize(resource.totalSize)}</td>
               <td>${resource.blobCount.toLocaleString()}</td>
               <td>${resource.containerCount}</td>
               <td>${resource.folderCount}</td>` : 
              `<td>${tagCount > 0 ? `${tagCount} tags` : '--'}</td>`}
          </tr>
        `;
      });
      
      html += `
            </tbody>
          </table>
        </div>
      `;
      
      // Add location breakdown
      const locationCounts = {};
      resources.forEach(r => {
        locationCounts[r.location] = (locationCounts[r.location] || 0) + 1;
      });
      
      const sortedLocations = Object.entries(locationCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
      
      if (sortedLocations.length > 0) {
        html += `
          <h3 style="margin-top: 20px; color: #00d4ff;">Distribution by Location</h3>
          <table class="data-table" style="margin-top: 10px;">
            <thead>
              <tr>
                <th>Location</th>
                <th>Count</th>
                <th>Percentage</th>
              </tr>
            </thead>
            <tbody>
        `;
        
        sortedLocations.forEach(([location, count]) => {
          const percentage = ((count / resources.length) * 100).toFixed(1);
          html += `
            <tr>
              <td>${location}</td>
              <td>${count}</td>
              <td>${percentage}%</td>
            </tr>
          `;
        });
        
        html += '</tbody></table>';
      }
      
      modalBody.innerHTML = html;
    }
    
    window.closeModal = function() {
      const modal = document.getElementById('detailModal');
      modal.classList.remove('active');
    }
    
    // Close modal when clicking outside
    window.onclick = function(event) {
      const modal = document.getElementById('detailModal');
      if (event.target === modal) {
        modal.classList.remove('active');
      }
    }

    // AI Models Usage Tracking - Updated pricing as of 2024
    const modelPricing = {
      'gpt4o-mini': { input: 0.00015, output: 0.0006 }, // per 1K tokens ($0.15/$0.60 per 1M)
      'embeddings': { input: 0.00002 }, // per 1K tokens for text-embedding-3-small
      'document': {
        'prebuilt-read': 0.001, // per page
        'prebuilt-layout': 0.01, // per page
        'prebuilt-document': 0.01, // per page  
        'prebuilt-invoice': 0.01 // per page
      }
    };
    
    // Add Token/Page/Custom Usage
    window.addTokenUsage = function(model) {
      let usage = JSON.parse(localStorage.getItem('aiUsage') || '{}');
      const currentMonth = new Date().toISOString().slice(0, 7); // YYYY-MM
      
      if (!usage[currentMonth]) {
        usage[currentMonth] = {
          'gpt4o-mini': { tokens: 0, cost: 0 },
          'embeddings': { tokens: 0, cost: 0 },
          'document': { pages: 0, cost: 0 },
          'custom': { entries: [], totalCost: 0 },
          history: []
        };
      }
      
      if (model === 'document') {
        const pages = parseInt(document.getElementById('documentInput').value) || 0;
        const docModel = document.getElementById('documentModel').value;
        
        if (pages > 0) {
          const cost = pages * modelPricing.document[docModel];
          usage[currentMonth].document.pages += pages;
          usage[currentMonth].document.cost += cost;
          
          // Add to history
          const modelName = docModel.replace('prebuilt-', '').charAt(0).toUpperCase() + 
                           docModel.replace('prebuilt-', '').slice(1);
          usage[currentMonth].history.unshift({
            timestamp: new Date().toISOString(),
            model: `Document Intelligence (${modelName})`,
            amount: `${pages} pages`,
            cost: cost
          });
          
          // Clear input
          document.getElementById('documentInput').value = '';
        }
      } else if (model === 'custom') {
        const name = document.getElementById('customModelName').value;
        const cost = parseFloat(document.getElementById('customCost').value) || 0;
        
        if (name && cost > 0) {
          if (!usage[currentMonth].custom) {
            usage[currentMonth].custom = { entries: [], totalCost: 0 };
          }
          
          usage[currentMonth].custom.entries.push({ name, cost });
          usage[currentMonth].custom.totalCost += cost;
          
          // Add to history
          usage[currentMonth].history.unshift({
            timestamp: new Date().toISOString(),
            model: name,
            amount: 'Custom usage',
            cost: cost
          });
          
          // Clear inputs
          document.getElementById('customModelName').value = '';
          document.getElementById('customCost').value = '';
        }
      } else if (model === 'embeddings') {
        const tokens = parseInt(document.getElementById('embeddingsInput').value) || 0;
        
        if (tokens > 0) {
          const cost = tokens * modelPricing.embeddings.input / 1000;
          
          if (!usage[currentMonth].embeddings) {
            usage[currentMonth].embeddings = { tokens: 0, cost: 0 };
          }
          
          usage[currentMonth].embeddings.tokens += tokens;
          usage[currentMonth].embeddings.cost += cost;
          
          // Add to history
          usage[currentMonth].history.unshift({
            timestamp: new Date().toISOString(),
            model: 'Text Embeddings',
            amount: `${tokens.toLocaleString()} tokens`,
            cost: cost
          });
          
          // Clear input
          document.getElementById('embeddingsInput').value = '';
        }
      } else {
        // GPT-4o mini
        const tokens = parseInt(document.getElementById('gpt4oMiniInput').value) || 0;
        
        if (tokens > 0) {
          // Estimate 70% input, 30% output for cost calculation
          const inputTokens = Math.floor(tokens * 0.7);
          const outputTokens = Math.floor(tokens * 0.3);
          const cost = (inputTokens * modelPricing['gpt4o-mini'].input / 1000) + 
                      (outputTokens * modelPricing['gpt4o-mini'].output / 1000);
          
          if (!usage[currentMonth]['gpt4o-mini']) {
            usage[currentMonth]['gpt4o-mini'] = { tokens: 0, cost: 0 };
          }
          
          usage[currentMonth]['gpt4o-mini'].tokens += tokens;
          usage[currentMonth]['gpt4o-mini'].cost += cost;
          
          // Add to history
          usage[currentMonth].history.unshift({
            timestamp: new Date().toISOString(),
            model: 'GPT-4o Mini',
            amount: `${tokens.toLocaleString()} tokens`,
            cost: cost
          });
          
          // Clear input
          document.getElementById('gpt4oMiniInput').value = '';
        }
      }
      
      // Keep only last 10 history items
      if (usage[currentMonth].history.length > 10) {
        usage[currentMonth].history = usage[currentMonth].history.slice(0, 10);
      }
      
      localStorage.setItem('aiUsage', JSON.stringify(usage));
      updateAIUsageDisplay();
      showMessage('AI usage added successfully!', 'success');
    }
    
    // Update AI Usage Display
    function updateAIUsageDisplay() {
      const usage = JSON.parse(localStorage.getItem('aiUsage') || '{}');
      const currentMonth = new Date().toISOString().slice(0, 7);
      const monthData = usage[currentMonth] || {
        'gpt4o-mini': { tokens: 0, cost: 0 },
        'embeddings': { tokens: 0, cost: 0 },
        'document': { pages: 0, cost: 0 },
        'custom': { entries: [], totalCost: 0 },
        history: []
      };
      
      // Update displays
      document.getElementById('gpt4oMiniTokens').textContent = (monthData['gpt4o-mini']?.tokens || 0).toLocaleString();
      document.getElementById('gpt4oMiniCost').textContent = `$${(monthData['gpt4o-mini']?.cost || 0).toFixed(4)}`;
      
      document.getElementById('embeddingsTokens').textContent = (monthData['embeddings']?.tokens || 0).toLocaleString();
      document.getElementById('embeddingsCost').textContent = `$${(monthData['embeddings']?.cost || 0).toFixed(4)}`;
      
      document.getElementById('documentPages').textContent = (monthData['document']?.pages || 0).toLocaleString();
      document.getElementById('documentCost').textContent = `$${(monthData['document']?.cost || 0).toFixed(2)}`;
      
      // Update custom usage
      const customCount = monthData['custom']?.entries?.length || 0;
      document.getElementById('customUsage').textContent = customCount > 0 ? `${customCount} items` : '--';
      document.getElementById('customTotalCost').textContent = `$${(monthData['custom']?.totalCost || 0).toFixed(2)}`;
      
      // Calculate total AI cost
      const totalCost = (monthData['gpt4o-mini']?.cost || 0) + 
                       (monthData['embeddings']?.cost || 0) + 
                       (monthData['document']?.cost || 0) + 
                       (monthData['custom']?.totalCost || 0);
      document.getElementById('totalAiCost').textContent = `$${totalCost.toFixed(2)}`;
      
      // Calculate daily rate and projection
      const dayOfMonth = new Date().getDate();
      const dailyRate = totalCost / dayOfMonth;
      const daysInMonth = new Date(new Date().getFullYear(), new Date().getMonth() + 1, 0).getDate();
      const projectedMonthly = dailyRate * daysInMonth;
      
      document.getElementById('aiDailyRate').textContent = `$${dailyRate.toFixed(2)}`;
      document.getElementById('aiProjectedMonthly').textContent = `$${projectedMonthly.toFixed(2)}`;
      
      // Update history
      const historyEl = document.getElementById('apiUsageHistory');
      if (monthData.history && monthData.history.length > 0) {
        historyEl.innerHTML = monthData.history.map(item => {
          const date = new Date(item.timestamp);
          return `
            <div style="border-bottom: 1px solid rgba(0, 212, 255, 0.1); padding: 5px 0; font-size: 11px;">
              <div style="display: flex; justify-content: space-between;">
                <span style="color: #00d4ff;">${item.model}</span>
                <span style="color: #10b981;">$${item.cost.toFixed(2)}</span>
              </div>
              <div style="display: flex; justify-content: space-between; margin-top: 2px;">
                <span style="color: #94a3b8;">${item.amount}</span>
                <span style="color: #64748b;">${date.toLocaleTimeString()}</span>
              </div>
            </div>
          `;
        }).join('');
      } else {
        historyEl.innerHTML = '<div style="color: #94a3b8; font-size: 12px;">No usage recorded</div>';
      }
    }
    
    // Fetch Azure OpenAI Usage
    window.fetchAzureOpenAIUsage = async function() {
      try {
        showMessage('Fetching Azure OpenAI usage data...', 'info');
        
        const subscriptionId = document.getElementById('subscriptionId').value;
        
        // Get Azure OpenAI resources
        const resources = await getResources();
        const openAIResources = resources?.value?.filter(r => 
          r.type.toLowerCase() === 'microsoft.cognitiveservices/accounts' &&
          (r.kind?.toLowerCase().includes('openai') || r.name.toLowerCase().includes('openai'))
        ) || [];
        
        if (openAIResources.length === 0) {
          showMessage('No Azure OpenAI resources found in your subscription', 'info');
          return;
        }
        
        // Get usage metrics for each Azure OpenAI resource
        let totalTokens = 0;
        let totalCost = 0;
        
        for (const resource of openAIResources) {
          const rgMatch = resource.id.match(/resourceGroups\/([^\/]+)/);
          const resourceGroup = rgMatch ? rgMatch[1] : '';
          
          try {
            // Get metrics for the resource
            const today = new Date();
            const startDate = new Date(today.getFullYear(), today.getMonth(), 1).toISOString().split('T')[0];
            const endDate = today.toISOString().split('T')[0];
            
            const metricsEndpoint = `/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/providers/Microsoft.CognitiveServices/accounts/${resource.name}/providers/Microsoft.Insights/metrics?api-version=2018-01-01&metricnames=TokenTransaction&timespan=${startDate}T00:00:00Z/${endDate}T23:59:59Z&aggregation=Total`;
            const metricsData = await callAzureAPI(metricsEndpoint);
            
            if (metricsData?.value?.[0]?.timeseries?.[0]?.data) {
              const dataPoints = metricsData.value[0].timeseries[0].data;
              dataPoints.forEach(point => {
                if (point.total) {
                  totalTokens += point.total;
                }
              });
            }
          } catch (error) {
            console.log(`Could not fetch metrics for ${resource.name}:`, error);
          }
        }
        
        // Update usage display
        let usage = JSON.parse(localStorage.getItem('aiUsage') || '{}');
        const currentMonth = new Date().toISOString().slice(0, 7);
        
        if (!usage[currentMonth]) {
          usage[currentMonth] = {
            'gpt4o-mini': { tokens: 0, cost: 0 },
            'embeddings': { tokens: 0, cost: 0 },
            'document': { pages: 0, cost: 0 },
            'custom': { entries: [], totalCost: 0 },
            'azureOpenAI': { tokens: 0, cost: 0 },
            history: []
          };
        }
        
        // Estimate cost based on Azure OpenAI pricing
        totalCost = (totalTokens / 1000) * 0.002; // Rough estimate
        
        usage[currentMonth].azureOpenAI = { tokens: totalTokens, cost: totalCost };
        
        // Add to history
        if (totalTokens > 0) {
          usage[currentMonth].history.unshift({
            timestamp: new Date().toISOString(),
            model: 'Azure OpenAI Service',
            amount: `${totalTokens.toLocaleString()} tokens`,
            cost: totalCost
          });
        }
        
        localStorage.setItem('aiUsage', JSON.stringify(usage));
        updateAIUsageDisplay();
        
        showMessage(`Azure OpenAI: ${totalTokens.toLocaleString()} tokens used this month ($${totalCost.toFixed(2)})`, 'success');
        
      } catch (error) {
        console.error('Error fetching Azure OpenAI usage:', error);
        showMessage('Error fetching Azure OpenAI usage. Check your permissions.', 'error');
      }
    }
    
    // Fetch Cognitive Services Usage
    window.fetchCognitiveServicesUsage = async function() {
      try {
        showMessage('Fetching Cognitive Services usage data...', 'info');
        
        const subscriptionId = document.getElementById('subscriptionId').value;
        
        // Query Cost Management API for Cognitive Services costs
        const endpoint = `/subscriptions/${subscriptionId}/providers/Microsoft.CostManagement/query?api-version=2023-03-01`;
        
        const body = {
          type: 'ActualCost',
          dataSet: {
            granularity: 'None',
            aggregation: {
              totalCost: {
                name: 'Cost',
                function: 'Sum'
              },
              totalCostUSD: {
                name: 'CostUSD',
                function: 'Sum'
              }
            },
            filter: {
              dimensions: {
                name: 'ServiceName',
                operator: 'In',
                values: ['Cognitive Services', 'Azure OpenAI', 'Azure Applied AI Services']
              }
            }
          },
          timeframe: 'MonthToDate'
        };
        
        const costData = await callAzureAPI(endpoint, {
          method: 'POST',
          body: JSON.stringify(body)
        });
        
        let totalCost = 0;
        if (costData?.properties?.rows) {
          costData.properties.rows.forEach(row => {
            totalCost += row[0] || 0;
          });
        }
        
        // Update display
        document.getElementById('apiKeyStatus').textContent = 
          `Azure Cognitive Services MTD: $${totalCost.toFixed(2)}`;
        document.getElementById('apiKeyStatus').style.color = '#10b981';
        
        showMessage(`Cognitive Services month-to-date cost: $${totalCost.toFixed(2)}`, 'success');
        
        // Also check for specific AI resources
        const resources = await getResources();
        const aiResources = resources?.value?.filter(r => 
          r.type.toLowerCase().includes('cognitiveservices') ||
          r.type.toLowerCase().includes('openai')
        ) || [];
        
        if (aiResources.length > 0) {
          console.log(`Found ${aiResources.length} AI/Cognitive Services resources:`);
          aiResources.forEach(r => {
            console.log(`- ${r.name} (${r.kind || r.type})`);
          });
        }
        
      } catch (error) {
        console.error('Error fetching Cognitive Services usage:', error);
        showMessage('Error fetching Cognitive Services usage. This requires Cost Management Reader role.', 'error');
      }
    }
    
    // Reset AI Usage (for new month)
    window.resetAIUsage = function() {
      if (confirm('Reset all AI usage data for this month?')) {
        const usage = JSON.parse(localStorage.getItem('aiUsage') || '{}');
        const currentMonth = new Date().toISOString().slice(0, 7);
        
        if (usage[currentMonth]) {
          delete usage[currentMonth];
          localStorage.setItem('aiUsage', JSON.stringify(usage));
          updateAIUsageDisplay();
          showMessage('AI usage data reset for this month', 'success');
        }
      }
    }
    
    // Save Tool Cost
    window.saveToolCost = function(tool) {
      let costs = JSON.parse(localStorage.getItem('toolCosts') || '{}');
      
      if (tool === 'other') {
        const name = document.getElementById('otherToolName').value;
        const cost = parseFloat(document.getElementById('otherToolCost').value) || 0;
        
        if (name && cost > 0) {
          if (!costs.others) costs.others = {};
          costs.others[name] = cost;
          
          // Clear inputs
          document.getElementById('otherToolName').value = '';
          document.getElementById('otherToolCost').value = '';
          
          // Update display
          updateOtherToolsList(costs.others);
        }
      } else {
        const costInput = document.getElementById(`${tool}Cost`);
        const cost = parseFloat(costInput.value) || 0;
        
        costs[tool] = cost;
        
        // Update saved display
        document.getElementById(`${tool}Saved`).textContent = `$${cost.toFixed(2)}/month`;
        
        // Clear input
        costInput.value = '';
      }
      
      localStorage.setItem('toolCosts', JSON.stringify(costs));
      updateToolCostTotals();
      
      showMessage(`${tool === 'other' ? 'Tool' : tool.charAt(0).toUpperCase() + tool.slice(1)} cost saved!`, 'success');
    }
    
    // Update Other Tools List
    function updateOtherToolsList(others) {
      const listEl = document.getElementById('otherToolsList');
      
      if (!others || Object.keys(others).length === 0) {
        listEl.textContent = 'No tools added';
      } else {
        const items = Object.entries(others).map(([name, cost]) => 
          `<div style="display: flex; justify-content: space-between; margin: 2px 0;">
            <span>${name}</span>
            <span style="color: #00d4ff;">$${cost.toFixed(2)}</span>
            <button onclick="removeOtherTool('${name}')" style="background: none; border: none; color: #ef4444; cursor: pointer; margin-left: 10px;">×</button>
          </div>`
        ).join('');
        listEl.innerHTML = items;
      }
    }
    
    // Remove Other Tool
    window.removeOtherTool = function(name) {
      let costs = JSON.parse(localStorage.getItem('toolCosts') || '{}');
      if (costs.others && costs.others[name]) {
        delete costs.others[name];
        if (Object.keys(costs.others).length === 0) {
          delete costs.others;
        }
        localStorage.setItem('toolCosts', JSON.stringify(costs));
        updateOtherToolsList(costs.others);
        updateToolCostTotals();
        showMessage(`${name} removed`, 'success');
      }
    }
    
    // Update Tool Cost Totals
    function updateToolCostTotals() {
      const costs = JSON.parse(localStorage.getItem('toolCosts') || '{}');
      
      let totalTools = 0;
      totalTools += costs.warp || 0;
      totalTools += costs.claude || 0;
      totalTools += costs.chatgpt || 0;
      
      if (costs.others) {
        Object.values(costs.others).forEach(cost => {
          totalTools += cost;
        });
      }
      
      // Update total tools cost
      document.getElementById('totalToolsCost').textContent = `$${totalTools.toFixed(2)}`;
      
      // Get Azure projected monthly cost
      const projectedCostEl = document.getElementById('projectedCost');
      let azureMonthlyCost = 0;
      if (projectedCostEl && projectedCostEl.textContent !== '--') {
        azureMonthlyCost = parseFloat(projectedCostEl.textContent.replace('$', '')) || 0;
      }
      
      // Calculate combined costs
      const combinedMonthly = azureMonthlyCost + totalTools;
      const annualCost = combinedMonthly * 12;
      const dailyCost = combinedMonthly / 30;
      
      // Update displays
      document.getElementById('combinedMonthlyCost').textContent = `$${combinedMonthly.toFixed(2)}`;
      document.getElementById('annualProjection').textContent = `$${annualCost.toFixed(2)}`;
      document.getElementById('dailyCostEstimate').textContent = `$${dailyCost.toFixed(2)}`;
    }
    
    // Load saved tool costs on init
    function loadSavedToolCosts() {
      const costs = JSON.parse(localStorage.getItem('toolCosts') || '{}');
      
      // Update individual tool displays
      if (costs.warp) {
        document.getElementById('warpSaved').textContent = `$${costs.warp.toFixed(2)}/month`;
      }
      if (costs.claude) {
        document.getElementById('claudeSaved').textContent = `$${costs.claude.toFixed(2)}/month`;
      }
      if (costs.chatgpt) {
        document.getElementById('chatgptSaved').textContent = `$${costs.chatgpt.toFixed(2)}/month`;
      }
      
      // Update other tools list
      if (costs.others) {
        updateOtherToolsList(costs.others);
      }
      
      // Update totals
      updateToolCostTotals();
    }
    
    // Explain Backup Status function
    window.explainBackupStatus = function(type) {
      const modal = document.getElementById('detailModal');
      const modalTitle = document.getElementById('modalTitle');
      const modalBody = document.getElementById('modalBody');
      
      let title, explanation;
      const statusEl = document.getElementById(`${type === 'azure' ? 'azureBackup' : type === 'k8s' ? 'k8sBackup' : type === 'postgres' ? 'postgres' : 'vault'}Status`);
      const statusIcon = statusEl ? statusEl.textContent : '❓';
      
      switch(type) {
        case 'azure':
          title = 'Azure Backups Repository';
          explanation = `
            <h3 style="color: #00d4ff;">Status Icons Explained:</h3>
            <div style="margin: 20px 0;">
              <p><span style="font-size: 24px;">✅</span> <strong>Green Check:</strong> Backups are running successfully. Recent backups found in Azure storage.</p>
              <p><span style="font-size: 24px;">⚠️</span> <strong>Warning:</strong> Backup configuration exists but may need attention.</p>
              <p><span style="font-size: 24px;">❌</span> <strong>Red X:</strong> No backup configuration found or backups failing.</p>
              <p><span style="font-size: 24px;">❓</span> <strong>Question Mark:</strong> Unable to determine backup status (check permissions).</p>
              <p><span style="font-size: 24px;">⏳</span> <strong>Hourglass:</strong> Currently checking backup status...</p>
            </div>
            <h3 style="color: #00d4ff; margin-top: 20px;">Current Status: ${statusIcon}</h3>
            <p>This monitors your Azure Backup vault and storage accounts for recent backup activities. It checks for:</p>
            <ul style="text-align: left; margin: 10px 20px;">
              <li>Recovery Services Vaults</li>
              <li>Backup storage accounts (saxtech-azure-backups)</li>
              <li>Recent backup job completions</li>
              <li>Backup policy compliance</li>
            </ul>
          `;
          break;
          
        case 'k8s':
          title = 'Kubernetes (n8n-aks) Backup';
          explanation = `
            <h3 style="color: #00d4ff;">Status Icons Explained:</h3>
            <div style="margin: 20px 0;">
              <p><span style="font-size: 24px;">✅</span> <strong>Green Check:</strong> AKS cluster is running and backups are configured.</p>
              <p><span style="font-size: 24px;">⚠️</span> <strong>Warning:</strong> Cluster exists but is stopped or degraded.</p>
              <p><span style="font-size: 24px;">❌</span> <strong>Red X:</strong> No AKS cluster found.</p>
              <p><span style="font-size: 24px;">❓</span> <strong>Question Mark:</strong> Unable to determine cluster status.</p>
            </div>
            <h3 style="color: #00d4ff; margin-top: 20px;">Current Status: ${statusIcon}</h3>
            <p>This monitors your n8n automation platform running on Azure Kubernetes Service (AKS). It checks:</p>
            <ul style="text-align: left; margin: 10px 20px;">
              <li>AKS cluster health and running state</li>
              <li>Persistent volume backups</li>
              <li>Kubernetes workload snapshots</li>
              <li>n8n workflow backup status</li>
            </ul>
          `;
          break;
          
        case 'postgres':
          title = 'PostgreSQL Maintenance';
          explanation = `
            <h3 style="color: #00d4ff;">Status Icons Explained:</h3>
            <div style="margin: 20px 0;">
              <p><span style="font-size: 24px;">✅</span> <strong>Green Check:</strong> PostgreSQL databases are online and maintenance is up to date.</p>
              <p><span style="font-size: 24px;">⚠️</span> <strong>Warning:</strong> Database found but maintenance may be needed.</p>
              <p><span style="font-size: 24px;">❌</span> <strong>Red X:</strong> No PostgreSQL databases found.</p>
              <p><span style="font-size: 24px;">❓</span> <strong>Question Mark:</strong> Unable to determine database status.</p>
            </div>
            <h3 style="color: #00d4ff; margin-top: 20px;">Current Status: ${statusIcon}</h3>
            <p>This monitors your PostgreSQL database servers and their maintenance status. It tracks:</p>
            <ul style="text-align: left; margin: 10px 20px;">
              <li>Database server availability</li>
              <li>Automated backup schedules</li>
              <li>Point-in-time restore capability</li>
              <li>Maintenance window compliance</li>
              <li>Geo-redundant backup status</li>
            </ul>
          `;
          break;
          
        case 'vault':
          title = 'Recovery Vault';
          explanation = `
            <h3 style="color: #00d4ff;">Status Icons Explained:</h3>
            <div style="margin: 20px 0;">
              <p><span style="font-size: 24px;">✅</span> <strong>Green Check:</strong> Recovery vault is active with protected items.</p>
              <p><span style="font-size: 24px;">⚠️</span> <strong>Warning:</strong> Vault exists but has no protected items or needs configuration.</p>
              <p><span style="font-size: 24px;">❌</span> <strong>Red X:</strong> No recovery vault found.</p>
              <p><span style="font-size: 24px;">❓</span> <strong>Question Mark:</strong> Unable to determine vault status.</p>
            </div>
            <h3 style="color: #00d4ff; margin-top: 20px;">Current Status: ${statusIcon}</h3>
            <p>Azure Recovery Services Vault is the central backup repository. It manages:</p>
            <ul style="text-align: left; margin: 10px 20px;">
              <li>VM backup policies and schedules</li>
              <li>File and folder backup configurations</li>
              <li>SQL database backup policies</li>
              <li>Disaster recovery configurations</li>
              <li>Cross-region replication settings</li>
            </ul>
          `;
          break;
      }
      
      modalTitle.textContent = title;
      modalBody.innerHTML = explanation;
      modal.classList.add('active');
    }
    
    // Initialize on page load
    window.addEventListener('load', async () => {
      // Load saved subscription ID
      const savedSubscription = localStorage.getItem('azure_subscription');
      if (savedSubscription) {
        document.getElementById('subscriptionId').value = savedSubscription;
      }
      
      // Load saved tool costs
      loadSavedToolCosts();
      
      // Load AI usage data
      updateAIUsageDisplay();
      
      // Check for saved API key
      const maskedKey = localStorage.getItem('openaiKeyMasked');
      if (maskedKey) {
        document.getElementById('apiKeyStatus').textContent = `API key saved: ${maskedKey}`;
        document.getElementById('apiKeyStatus').style.color = '#10b981';
      }

      // Initialize MSAL
      await initializeMSAL();
    });
  </script>
</body>
</html>
